<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Play Free Mini Games</title>
    
    <!-- External CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css">
    
    <!-- External Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/particles.js@2.0.0/particles.min.js"></script>

    <style>
        /* Base Styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Comic Sans MS', sans-serif;
            background: #111;
            color: #fff;
            overflow-x: hidden;
        }

        /* Particles Container */
        #particles-js {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, #111111 0%, #1a1a1a 100%);
            z-index: 0;
        }

        #particles-js canvas {
            display: block;
            animation: fadeIn 2s ease-in-out;
            filter: blur(0.5px);
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        #app {
            position: relative;
            z-index: 1;
        }

        /* Header Styles */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            padding: 20px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            z-index: 1000;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo {
            font-size: 2rem;
            color: #f39c12;
            text-shadow: 0 0 10px rgba(243, 156, 18, 0.5);
            margin: 0;
        }

        .nav ul {
            display: flex;
            list-style: none;
            gap: 30px;
            margin: 0;
            padding: 0;
        }

        .nav-link {
            color: #fff;
            text-decoration: none;
            font-size: 1.1rem;
            padding: 8px 16px;
            border-radius: 20px;
            transition: all 0.3s ease;
        }

        .nav-link:hover {
            color: #f39c12;
            background: rgba(243, 156, 18, 0.1);
            transform: translateY(-2px);
        }

        /* Hero Section */
        .hero {
            min-height: 100vh;
            display: flex;
            align-items: center;
            padding: 50px;
            position: relative;
        }

        .hero-content {
            max-width: 600px;
            animation: slideUp 1s ease-out;
        }

        .hero-title {
            font-size: 4rem;
            margin-bottom: 20px;
            color: #f39c12;
            text-shadow: 0 0 20px rgba(243, 156, 18, 0.5);
            animation: glow 2s ease-in-out infinite;
        }

        .hero-text {
            font-size: 1.5rem;
            margin-bottom: 30px;
        }

        /* Games Section */
        .games-section {
            padding: 80px 20px;
            background: rgba(0, 0, 0, 0.7);
        }

        .section-title {
            text-align: center;
            font-size: 3rem;
            margin-bottom: 50px;
            color: #f39c12;
            text-shadow: 0 0 15px rgba(243, 156, 18, 0.3);
        }

        .game-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 30px;
            max-width: 1200px;
            margin: 0 auto;
        }

        .game-item {
            background: rgba(30, 30, 47, 0.8);
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            transition: all 0.3s ease;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
            animation: fadeIn 0.5s ease-out;
            animation-fill-mode: both;
        }

        .game-item:nth-child(1) { animation-delay: 0.2s; }
        .game-item:nth-child(2) { animation-delay: 0.4s; }
        .game-item:nth-child(3) { animation-delay: 0.6s; }
        .game-item:nth-child(4) { animation-delay: 0.8s; }

        .game-item:hover {
            transform: translateY(-10px);
            box-shadow: 0 15px 30px rgba(243, 156, 18, 0.3);
        }

        .game-item h3 {
            color: #f39c12;
            font-size: 1.8rem;
            margin-bottom: 15px;
        }

        .game-item p {
            margin-bottom: 20px;
            color: #ddd;
        }

        /* Button Styles */
        .btn {
            display: inline-block;
            padding: 12px 30px;
            background: #f39c12;
            color: #000;
            border: none;
            border-radius: 30px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(243, 156, 18, 0.4);
        }

        .btn:after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.6s ease, height 0.6s ease;
        }

        .btn:hover:after {
            width: 300px;
            height: 300px;
        }

        /* Modal Styles */
        .modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 2000;
            transition: opacity 0.3s ease;
        }

        .modal.active {
            display: flex;
        justify-content: center;
        align-items: center;
    }

    .modal-content {
            background: #1e1e2f;
            padding: 30px;
            border-radius: 20px;
            max-width: 90%;
            width: 600px;
            position: relative;
            transform: scale(0.7);
            opacity: 0;
            transition: all 0.3s ease;
        }

        .modal.active .modal-content {
            transform: scale(1);
            opacity: 1;
    }

    .close-btn {
        position: absolute;
        top: 10px;
        right: 10px;
            font-size: 24px;
            color: #fff;
            cursor: pointer;
            background: none;
            border: none;
        }

        /* Enhanced Game Board Styles */
        .game-board {
            position: relative;
            width: 300px;
            height: 300px;
        display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin: 20px auto;
            padding: 15px;
            background: rgba(30, 30, 47, 0.5);
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            overflow: visible;
    }

    .cell {
            aspect-ratio: 1;
            background: rgba(30, 30, 47, 0.8);
            border-radius: 10px;
        display: flex;
        align-items: center;
        justify-content: center;
            font-size: 2.5rem;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.2);
            position: relative;
            z-index: 0;
        }

        .cell:hover {
            background: rgba(243, 156, 18, 0.2);
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(243, 156, 18, 0.3);
        }

        .cell.x {
            color: #e74c3c;
            text-shadow: 0 0 10px rgba(231, 76, 60, 0.5);
        }

        .cell.o {
            color: #3498db;
            text-shadow: 0 0 10px rgba(52, 152, 219, 0.5);
        }

        /* 2048 Game Enhanced Styles */
        #game2048-board {
            display: grid;
            gap: 12px;
            padding: 15px;
            transition: all 0.3s ease;
        }

        #game2048-board.grid-4 {
            grid-template-columns: repeat(4, 1fr);
        font-size: 2rem;
        }

        #game2048-board.grid-5 {
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
            font-size: 1.8rem;
        }

        #game2048-board.grid-6 {
            grid-template-columns: repeat(6, 1fr);
            gap: 8px;
            font-size: 1.6rem;
        }

        #game2048-board.grid-7 {
            grid-template-columns: repeat(7, 1fr);
            gap: 6px;
            font-size: 1.4rem;
        }

        #game2048-score-panel {
            display: flex;
            justify-content: space-around;
            margin: 20px 0;
            font-size: 1.3rem;
            color: #f39c12;
        }

        .game2048-cell {
            aspect-ratio: 1;
            background: rgba(238, 228, 218, 0.2);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.8rem;
        font-weight: bold;
            color: #f9f6f2;
            transition: all 0.15s ease;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.1);
        }

        /* Tile Colors with Glowing Effect */
        .tile-2 {
            background: #f39c12;
            color: #fff;
            text-shadow: 0 0 10px rgba(243, 156, 18, 0.5);
            box-shadow: 0 0 15px rgba(243, 156, 18, 0.3);
        }

        .tile-4 {
            background: #e67e22;
            color: #fff;
            text-shadow: 0 0 10px rgba(230, 126, 34, 0.5);
            box-shadow: 0 0 15px rgba(230, 126, 34, 0.3);
        }

        .tile-8 {
            background: #e74c3c;
            color: #fff;
            text-shadow: 0 0 10px rgba(231, 76, 60, 0.5);
            box-shadow: 0 0 15px rgba(231, 76, 60, 0.3);
        }

        .tile-16 {
            background: #c0392b;
            color: #fff;
            text-shadow: 0 0 10px rgba(192, 57, 43, 0.5);
            box-shadow: 0 0 15px rgba(192, 57, 43, 0.3);
        }

        .tile-32 {
            background: #9b59b6;
            color: #fff;
            text-shadow: 0 0 10px rgba(155, 89, 182, 0.5);
            box-shadow: 0 0 15px rgba(155, 89, 182, 0.3);
        }

        .tile-64 {
            background: #8e44ad;
            color: #fff;
            text-shadow: 0 0 10px rgba(142, 68, 173, 0.5);
            box-shadow: 0 0 15px rgba(142, 68, 173, 0.3);
        }

        .tile-128 {
            background: #3498db;
            color: #fff;
            font-size: 1.6rem;
            text-shadow: 0 0 10px rgba(52, 152, 219, 0.5);
            box-shadow: 0 0 20px rgba(52, 152, 219, 0.4);
        }

        .tile-256 {
            background: #2980b9;
            color: #fff;
            font-size: 1.6rem;
            text-shadow: 0 0 10px rgba(41, 128, 185, 0.5);
            box-shadow: 0 0 20px rgba(41, 128, 185, 0.4);
        }

        .tile-512 {
            background: #27ae60;
            color: #fff;
            font-size: 1.6rem;
            text-shadow: 0 0 10px rgba(39, 174, 96, 0.5);
            box-shadow: 0 0 20px rgba(39, 174, 96, 0.4);
        }

        .tile-1024 {
            background: #16a085;
            color: #fff;
            font-size: 1.4rem;
            text-shadow: 0 0 10px rgba(22, 160, 133, 0.5);
            box-shadow: 0 0 25px rgba(22, 160, 133, 0.5);
        }

        .tile-2048 {
            background: #2c3e50;
            color: #fff;
            font-size: 1.4rem;
            text-shadow: 0 0 10px rgba(44, 62, 80, 0.5);
            box-shadow: 0 0 30px rgba(44, 62, 80, 0.6);
        }

        /* Animation for new tiles */
        @keyframes appear {
            0% {
                opacity: 0;
                transform: scale(0);
            }
            50% {
                transform: scale(1.1);
            }
            100% {
                opacity: 1;
                transform: scale(1);
            }
        }

        .game2048-cell:not(:empty) {
            animation: appear 0.2s ease;
        }

        /* Score Panel Animation */
        @keyframes scoreUpdate {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .score-update {
            animation: scoreUpdate 0.3s ease-out;
        }

        @keyframes scoreUpdate {
            0% {
                transform: scale(1);
                color: #f39c12;
            }
            50% {
                transform: scale(1.2);
                color: #e74c3c;
            }
            100% {
                transform: scale(1);
                color: #f39c12;
            }
        }

        /* Responsive Design */
        @media (max-width: 500px) {
            #game2048-board {
                max-width: 320px;
                gap: 8px;
                padding: 10px;
            }

            .game2048-cell {
                font-size: 1.5rem;
            }

            .tile-128, .tile-256, .tile-512 {
                font-size: 1.3rem;
            }

            .tile-1024, .tile-2048 {
                font-size: 1.1rem;
            }
        }

        /* Memory Match Enhanced Styles */
        .memory-board {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 12px;
            margin: 20px auto;
            max-width: 500px;
            padding: 15px;
            background: rgba(30, 30, 47, 0.5);
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
        }

        .memory-card {
            aspect-ratio: 1;
            background: rgba(30, 30, 47, 0.8);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.5rem;
        cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.2);
            transform-style: preserve-3d;
        }

        .memory-card:hover:not(.matched) {
            transform: scale(1.05) rotateY(10deg);
            box-shadow: 0 0 20px rgba(243, 156, 18, 0.3);
        }

        .memory-card.flipped {
            transform: rotateY(180deg);
        }

        .memory-card.matched {
            background: #f39c12;
            box-shadow: 0 0 20px rgba(243, 156, 18, 0.5);
            animation: matchPulse 1s ease infinite;
        }

        @keyframes matchPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        /* Game Score Panel Styles */
        .game-score {
            font-size: 1.5rem;
            margin: 20px 0;
            color: #f39c12;
            text-align: center;
            text-shadow: 0 0 10px rgba(243, 156, 18, 0.3);
            background: rgba(30, 30, 47, 0.5);
        padding: 10px 20px;
            border-radius: 30px;
            backdrop-filter: blur(10px);
        }

        #game2048-score-panel {
            display: flex;
            justify-content: space-around;
            margin: 20px 0;
            gap: 20px;
        }

        #game2048-score-panel span {
            font-size: 1.3rem;
            color: #f39c12;
            background: rgba(30, 30, 47, 0.5);
            padding: 10px 20px;
            border-radius: 30px;
            backdrop-filter: blur(10px);
            flex: 1;
            text-align: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        /* Game Mode Select Styles */
        .game-mode-select {
            margin: 20px 0;
            text-align: center;
        }

        .game-mode-select select {
            padding: 8px 16px;
            font-size: 1rem;
            border-radius: 20px;
            background: rgba(243, 156, 18, 0.1);
            color: #fff;
            border: 2px solid #f39c12;
            cursor: pointer;
            outline: none;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
.hero-title {
            font-size: 3rem;
            }

            .hero-text {
                font-size: 1.2rem;
            }

            .games-section {
                padding: 50px 20px;
            }

            .modal-content {
            padding: 20px;
                width: 95%;
            }

            .game-board {
                max-width: 280px;
            }

            #game2048-board {
                max-width: 320px;
            }

            .memory-board {
                max-width: 320px;
            }
        }

        /* Footer Styles */
        .footer {
            background: rgba(0, 0, 0, 0.9);
            padding: 20px;
            text-align: center;
            margin-top: 50px;
        }

        .footer p {
            color: #ddd;
            margin: 10px 0;
        }

        .social-links {
            margin-top: 15px;
        }

        .social-links a {
            color: #f39c12;
            text-decoration: none;
            margin: 0 10px;
            transition: all 0.3s ease;
            position: relative;
        }

        .social-links a::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            width: 0;
            height: 2px;
            background: #f39c12;
            transition: width 0.3s ease;
        }

        .social-links a:hover {
            color: #fff;
            text-shadow: 0 0 10px rgba(243, 156, 18, 0.5);
        }

        .social-links a:hover::after {
            width: 100%;
        }

        /* Hero Section Animations */
        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes glow {
            0% { text-shadow: 0 0 10px rgba(243, 156, 18, 0.5); }
            50% { text-shadow: 0 0 20px rgba(243, 156, 18, 0.8); }
            100% { text-shadow: 0 0 10px rgba(243, 156, 18, 0.5); }
        }

        /* Game Items Animation */
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Game Board Animations */
        .cell, .game2048-cell, .memory-card {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .cell.x, .cell.o {
            animation: popIn 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        @keyframes popIn {
            0% {
                transform: scale(0);
            }
            70% {
                transform: scale(1.2);
            }
            100% {
                transform: scale(1);
            }
        }

        /* Smooth Scroll Behavior */
        html {
            scroll-behavior: smooth;
            scroll-padding-top: 80px; /* Height of your header */
        }

        /* Header Animation */
        .header {
            transition: background 0.3s ease, padding 0.3s ease;
        }

        .header.scrolled {
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.95);
        }

        /* Enhanced Particles Styles */
        #particles-js {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, #111111 0%, #1a1a1a 100%);
            z-index: 0;
        }

        #particles-js canvas {
            display: block;
            animation: fadeIn 2s ease-in-out;
            filter: blur(0.5px);
        }

        /* Particle Animation */
        @keyframes particleGlow {
            0% { filter: blur(0.5px); }
            50% { filter: blur(1px); }
            100% { filter: blur(0.5px); }
        }

        #particles-js canvas {
            animation: fadeIn 2s ease-in-out, particleGlow 4s ease-in-out infinite;
        }

        /* Responsive Header */
        @media (max-width: 768px) {
            .header {
                flex-direction: column;
                gap: 15px;
            }

            .nav ul {
                gap: 15px;
            }

            .nav-link {
                font-size: 1rem;
                padding: 6px 12px;
            }
        }

        html {
            scroll-behavior: smooth;
            scroll-padding-top: 80px; /* Height of your header */
        }

        .section {
            min-height: 100vh;
            padding: 80px 20px;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.6s ease;
        }

        .section.active {
            opacity: 1;
            transform: translateY(0);
        }

        /* About Section Styles */
        .about-section {
            background: linear-gradient(135deg, rgba(30, 30, 47, 0.95), rgba(20, 20, 35, 0.98));
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 60px 30px;
            position: relative;
            overflow: hidden;
        }

        .about-section::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle at 50% 50%, rgba(243, 156, 18, 0.1), transparent 70%);
            pointer-events: none;
        }

        .about-content {
            max-width: 1400px;
            width: 100%;
            margin: 0 auto;
    text-align: center;
            position: relative;
            z-index: 1;
        }

        .section-title {
            font-size: 3.5rem;
            color: #f39c12;
            margin-bottom: 60px;
            text-shadow: 0 0 15px rgba(243, 156, 18, 0.3);
            animation: glow 2s ease-in-out infinite alternate;
            font-weight: 700;
            letter-spacing: 2px;
        }

        .about-grid {
    display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 25px;
            margin: 40px auto;
            max-width: 1200px;
            padding: 0 20px;
        }

        .about-card {
            background: rgba(255, 255, 255, 0.03);
            padding: 35px 25px;
            border-radius: 20px;
            backdrop-filter: blur(10px);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            border: 1px solid rgba(255, 255, 255, 0.1);
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .about-card:hover {
            transform: translateY(-10px);
            background: rgba(255, 255, 255, 0.07);
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.2);
            border-color: rgba(243, 156, 18, 0.3);
        }

        .card-icon {
            font-size: 3.5rem;
            margin-bottom: 25px;
            animation: float 3s ease-in-out infinite;
            width: 80px;
            height: 80px;
    display: flex;
    align-items: center;
    justify-content: center;
            border-radius: 50%;
            margin-bottom: 25px;
            position: relative;
        }

        /* Different styles for each card icon */
        .about-card:nth-child(1) .card-icon {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            box-shadow: 0 0 20px rgba(231, 76, 60, 0.3);
    color: white;
}

        .about-card:nth-child(2) .card-icon {
            background: linear-gradient(135deg, #3498db, #2980b9);
            box-shadow: 0 0 20px rgba(52, 152, 219, 0.3);
    color: white;
}

        .about-card:nth-child(3) .card-icon {
            background: linear-gradient(135deg, #2ecc71, #27ae60);
            box-shadow: 0 0 20px rgba(46, 204, 113, 0.3);
            color: white;
        }

        .about-card:nth-child(4) .card-icon {
            background: linear-gradient(135deg, #9b59b6, #8e44ad);
            box-shadow: 0 0 20px rgba(155, 89, 182, 0.3);
            color: white;
        }

        /* Add shine effect to icons */
        .card-icon::after {
            content: '';
    position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: 50%;
            background: linear-gradient(45deg, 
                rgba(255,255,255,0.1) 0%, 
                rgba(255,255,255,0.2) 50%, 
                rgba(255,255,255,0) 100%);
        }

        /* Enhanced hover effect for cards */
        .about-card:hover .card-icon {
            transform: scale(1.1) translateY(-5px);
        }

        .about-card:nth-child(1):hover {
            border-color: rgba(231, 76, 60, 0.3);
        }

        .about-card:nth-child(2):hover {
            border-color: rgba(52, 152, 219, 0.3);
        }

        .about-card:nth-child(3):hover {
            border-color: rgba(46, 204, 113, 0.3);
        }

        .about-card:nth-child(4):hover {
            border-color: rgba(155, 89, 182, 0.3);
        }

        .about-card h3 {
            color: #f39c12;
            font-size: 1.6rem;
            margin-bottom: 20px;
            font-weight: 600;
            letter-spacing: 1px;
        }

        .about-card p {
            color: #eee;
            line-height: 1.7;
            font-size: 1.1rem;
            margin: 0;
            flex-grow: 1;
        }

        .about-footer {
            margin-top: 80px;
            background: rgba(255, 255, 255, 0.03);
            padding: 40px;
            border-radius: 30px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .stats {
            display: flex;
            justify-content: center;
            gap: 80px;
            margin-bottom: 50px;
        }

        .stat-item {
    text-align: center;
            padding: 20px 40px;
            background: rgba(243, 156, 18, 0.1);
            border-radius: 20px;
            transition: all 0.3s ease;
        }

        .stat-item:hover {
            transform: translateY(-5px);
            background: rgba(243, 156, 18, 0.15);
        }

        .stat-number {
            font-size: 3rem;
            color: #f39c12;
            display: block;
            margin-bottom: 10px;
    font-weight: bold;
            text-shadow: 0 0 10px rgba(243, 156, 18, 0.3);
        }

        .stat-label {
            color: #fff;
            font-size: 1.2rem;
            font-weight: 500;
            letter-spacing: 1px;
        }

        .social-links {
            display: flex;
            justify-content: center;
            gap: 40px;
            margin-top: 40px;
        }

        .social-link {
            color: #f39c12;
            text-decoration: none;
            padding: 12px 30px;
            border-radius: 30px;
            background: rgba(243, 156, 18, 0.1);
            transition: all 0.3s ease;
            font-size: 1.1rem;
            letter-spacing: 1px;
            border: 1px solid rgba(243, 156, 18, 0.2);
        }

        .social-link:hover {
            background: rgba(243, 156, 18, 0.2);
            transform: translateY(-3px);
            box-shadow: 0 5px 20px rgba(243, 156, 18, 0.3);
            border-color: rgba(243, 156, 18, 0.4);
        }

        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
            100% { transform: translateY(0px); }
        }

        @keyframes glow {
            from { text-shadow: 0 0 10px rgba(243, 156, 18, 0.3); }
            to { text-shadow: 0 0 25px rgba(243, 156, 18, 0.6); }
        }

        /* Responsive Design */
        @media (max-width: 1200px) {
            .about-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 30px;
            }
        }

        @media (max-width: 768px) {
            .section-title {
                font-size: 2.5rem;
                margin-bottom: 40px;
            }

            .about-grid {
                grid-template-columns: 1fr;
                gap: 25px;
            }

            .stats {
                flex-direction: column;
                gap: 20px;
            }

            .stat-item {
                padding: 15px 30px;
            }

            .social-links {
                flex-direction: column;
                align-items: center;
                gap: 20px;
            }

            .about-footer {
                padding: 30px 20px;
                margin-top: 60px;
            }
        }

        /* Active nav link style */
        .nav-link.active {
            color: #f39c12;
            background: rgba(243, 156, 18, 0.1);
        }

        /* Add these interactive styles */
        /* Floating Elements Animation */
        .floating {
            animation: float 3s ease-in-out infinite;
        }

        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
            100% { transform: translateY(0px); }
        }

        /* Interactive Game Items */
        .game-item {
            position: relative;
    overflow: hidden;
        }

        .game-item::before {
            content: '';
    position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(243, 156, 18, 0.1) 0%, transparent 70%);
            opacity: 0;
            transform: scale(0.5);
            transition: all 0.5s ease;
        }

        .game-item:hover::before {
            opacity: 1;
            transform: scale(1);
        }

        /* Pulse Animation for Buttons */
        .btn {
            position: relative;
        }

        .btn::after {
            content: '';
            position: absolute;
    width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            border-radius: 30px;
            background: rgba(243, 156, 18, 0.4);
            transform: scale(1.5);
            opacity: 0;
            transition: all 0.5s ease;
        }

        .btn:hover::after {
            animation: pulse 1.5s ease-out infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1.2); opacity: 0.5; }
            100% { transform: scale(2); opacity: 0; }
        }

        /* Interactive Nav Links */
        .nav-link {
            position: relative;
        }

        .nav-link::before {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 50%;
            width: 0;
            height: 2px;
            background: #f39c12;
            transition: all 0.3s ease;
            transform: translateX(-50%);
        }

        .nav-link:hover::before {
    width: 80%;
        }

        /* Loading Spinner */
        .loading {
    position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            backdrop-filter: blur(5px);
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #f39c12;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Scroll Progress Indicator */
        .scroll-progress {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 3px;
            background: rgba(243, 156, 18, 0.2);
            z-index: 1001;
        }

        .scroll-progress-bar {
            height: 100%;
            background: #f39c12;
            width: 0%;
            transition: width 0.2s ease;
        }

        /* Add to your CSS */
        .victory-line {
            position: absolute;
            transition: transform 0.3s ease;
            z-index: 2;
            pointer-events: none;
            box-shadow: 0 0 10px currentColor;
        }

        /* Horizontal lines */
        .victory-line.horizontal {
            height: 6px;
            width: 0;
            left: 0;
            transform-origin: left;
            animation: growHorizontal 0.5s forwards;
        }

        /* Vertical lines */
        .victory-line.vertical {
            width: 6px;
            height: 0;
            top: 0;
            transform-origin: top;
            animation: growVertical 0.5s forwards;
        }

        /* Diagonal lines */
        .victory-line.diagonal {
            height: 6px;
            width: 0;
            position: absolute;
            left: 50%;
            top: 50%;
            transform-origin: center;
        }

        .diagonal-1 {
            transform: translate(-50%, -50%) rotate(45deg);
            animation: growDiagonalOne 0.5s forwards;
        }

        .diagonal-2 {
            transform: translate(-50%, -50%) rotate(-45deg);
            animation: growDiagonalTwo 0.5s forwards;
        }

        @keyframes growHorizontal {
            to {
                width: 100%;
            }
        }

        @keyframes growVertical {
            to {
                height: 100%;
            }
        }

        @keyframes growDiagonalOne {
            from {
                width: 0;
            }
            to {
                width: 140%;
            }
        }

        @keyframes growDiagonalTwo {
            from {
                width: 0;
            }
            to {
                width: 140%;
            }
        }

        /* Victory line colors */
        .victory-line.x-win {
            background: #e74c3c;
            color: #e74c3c;
        }

        .victory-line.o-win {
            background: #3498db;
            color: #3498db;
        }

        /* Position classes for victory lines */
        .row-0 { top: 16.67%; }
        .row-1 { top: 50%; }
        .row-2 { top: 83.33%; }

        .col-0 { left: 16.67%; }
        .col-1 { left: 50%; }
        .col-2 { left: 83.33%; }

        /* Game Result Overlay */
        .game-result {
            position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            justify-content: center;
            align-items: center;
    opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            backdrop-filter: blur(5px);
    border-radius: 15px;
            z-index: 1000;
        }

        .game-result.active {
    opacity: 1;
            visibility: visible;
        }

        .result-content {
    text-align: center;
            transform: translateY(20px);
            transition: transform 0.3s ease;
            padding: 20px;
            background: rgba(30, 30, 47, 0.9);
            border-radius: 15px;
            box-shadow: 0 0 30px rgba(243, 156, 18, 0.2);
        }

        .game-result.active .result-content {
            transform: translateY(0);
        }

        .winner-text {
    font-size: 2rem;
            margin-bottom: 20px;
            color: #fff;
            text-shadow: 0 0 10px rgba(243, 156, 18, 0.5);
        }

        .winner-text.x-win {
            color: #e74c3c;
            text-shadow: 0 0 10px rgba(231, 76, 60, 0.5);
        }

        .winner-text.o-win {
            color: #3498db;
            text-shadow: 0 0 10px rgba(52, 152, 219, 0.5);
        }

        .rematch-btn {
    background: #f39c12;
    color: #fff;
            border: none;
            padding: 10px 30px;
            font-size: 1.2rem;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 0 20px rgba(243, 156, 18, 0.3);
        }

        .rematch-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 0 30px rgba(243, 156, 18, 0.5);
            background: #e67e22;
        }

        /* 2048 Game Result Styles */
        .game-result .score-info {
            margin: 20px 0;
            font-size: 1.2rem;
            color: #fff;
  display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .game-result .final-score {
            font-size: 2.8rem;
            color: #f39c12;
            margin: 10px 0;
            text-shadow: 0 0 15px rgba(243, 156, 18, 0.5);
            animation: pulseScore 1.5s ease-in-out infinite;
        }

        .game-result .high-score-text {
            color: #2ecc71;
            font-size: 1.8rem;
            margin: 10px 0;
    opacity: 0;
            transform: translateY(20px);
            transition: all 0.5s ease;
        }

        .game-result.new-highscore .result-content {
            animation: celebrate 0.5s ease infinite alternate;
            background: linear-gradient(45deg, rgba(46, 204, 113, 0.15), rgba(243, 156, 18, 0.15));
        }

        @keyframes celebrate {
            from {
                transform: translateY(0);
                box-shadow: 0 0 30px rgba(243, 156, 18, 0.2);
            }
            to {
                transform: translateY(-5px);
                box-shadow: 0 0 50px rgba(243, 156, 18, 0.4);
            }
        }

        @keyframes pulseScore {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .result-title {
            font-size: 2.2rem;
            margin-bottom: 20px;
            background: linear-gradient(45deg, #f39c12, #e74c3c);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 15px rgba(243, 156, 18, 0.3);
            line-height: 1.3;
        }

        .game-result .rematch-btn {
            margin-top: 20px;
            font-size: 1.3rem;
            padding: 12px 35px;
            background: linear-gradient(45deg, #f39c12, #e74c3c);
            border: none;
            color: white;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .game-result .rematch-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(243, 156, 18, 0.4);
        }

        /* Memory Match Game Styles */
        #memoryBoard {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            max-width: 500px;
    margin: 20px auto;
            perspective: 1000px;
            padding: 20px;
            background: rgba(30, 30, 47, 0.5);
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
}

.memory-card {
            aspect-ratio: 1;
            position: relative;
            cursor: pointer;
            transform-style: preserve-3d;
            transition: transform 0.2s ease;
        }

        .memory-card:hover {
            transform: translateY(-5px);
        }

        .card-inner {
            position: relative;
            width: 100%;
            height: 100%;
            transform-style: preserve-3d;
            transition: transform 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .memory-card.flipped .card-inner {
            transform: rotateY(180deg);
        }

        .card-front, .card-back {
            position: absolute;
  width: 100%;
  height: 100%;
            backface-visibility: hidden;
    display: flex;
    align-items: center;
    justify-content: center;
            font-size: 2.5rem;
            border-radius: 12px;
            background: rgba(30, 30, 47, 0.8);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
        }

        .card-front {
            background: linear-gradient(135deg, #f39c12, #e74c3c);
            box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.2);
        }

        .card-back {
            transform: rotateY(180deg);
            background: linear-gradient(135deg, #3498db, #2ecc71);
            box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.2);
        }

        .memory-card.matched .card-back {
            background: linear-gradient(135deg, #27ae60, #2ecc71);
            animation: matchPulse 0.5s ease-out;
            box-shadow: 0 0 20px rgba(46, 204, 113, 0.4);
        }

        @keyframes matchPulse {
            0% { 
                transform: rotateY(180deg) scale(1);
                box-shadow: 0 0 20px rgba(46, 204, 113, 0.4);
            }
            50% { 
                transform: rotateY(180deg) scale(1.1);
                box-shadow: 0 0 30px rgba(46, 204, 113, 0.6);
            }
            100% { 
                transform: rotateY(180deg) scale(1);
                box-shadow: 0 0 20px rgba(46, 204, 113, 0.4);
            }
        }

        #memoryStats {
  text-align: center;
            margin: 20px 0;
            padding: 15px;
            background: rgba(30, 30, 47, 0.5);
  border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(5px);
        }

        #memoryStats span {
            display: inline-block;
            margin: 0 15px;
            font-size: 1.3rem;
            color: #f39c12;
            text-shadow: 0 0 10px rgba(243, 156, 18, 0.3);
        }

        /* Memory Match Responsive Design */
        @media (max-width: 500px) {
            #memoryBoard {
                gap: 10px;
                padding: 15px;
            }

            .card-front, .card-back {
    font-size: 2rem;
            }

            #memoryStats span {
                font-size: 1.1rem;
                margin: 0 10px;
            }
        }

        /* Add restart button styles */
        #memoryRestartBtn {
            display: block;
            margin: 20px auto;
            padding: 10px 30px;
            font-size: 1.2rem;
            background: linear-gradient(135deg, #f39c12, #e74c3c);
  border: none;
            border-radius: 30px;
            color: white;
    cursor: pointer;
            transition: all 0.3s ease;
        }

        #memoryRestartBtn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(243, 156, 18, 0.4);
        }

        /* 2048 Game Settings */
        .game-settings {
            text-align: center;
            margin: 15px 0;
  padding: 10px;
            background: rgba(30, 30, 47, 0.5);
  border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .game-settings label {
            color: #f39c12;
            font-size: 1.2rem;
            margin-right: 10px;
        }

        .game-settings select {
            padding: 5px 15px;
            font-size: 1.1rem;
            background: rgba(30, 30, 47, 0.8);
    color: #fff;
            border: 2px solid #f39c12;
  border-radius: 5px;
  cursor: pointer;
            outline: none;
            transition: all 0.3s ease;
        }

        .game-settings select:hover {
            background: rgba(243, 156, 18, 0.2);
        }

        /* Adjust board size based on grid */
        #game2048-board.grid-5 {
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
            font-size: 0.9em;
        }

        #game2048-board.grid-6 {
            grid-template-columns: repeat(6, 1fr);
            gap: 8px;
            font-size: 0.8em;
        }

        #game2048-board.grid-7 {
            grid-template-columns: repeat(7, 1fr);
            gap: 6px;
            font-size: 0.7em;
        }

        /* Game Result Box Styles */
        .result-buttons {
  display: flex;
            gap: 15px;
  justify-content: center;
            margin-top: 20px;
        }

        .result-buttons .btn {
            padding: 10px 20px;
            font-size: 1.1rem;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .change-size-btn {
            background: linear-gradient(135deg, #3498db, #2980b9);
        }

        .change-size-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(52, 152, 219, 0.4);
        }

        /* Connect Dots Game Styles */
        #connectDotsModal .modal-content {
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            color: #fff;
            max-width: 800px;
            width: 90%;
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }

        #connectDotsModal h2 {
            text-align: center;
            font-size: 2.5rem;
            color: #f39c12;
            margin-bottom: 20px;
            text-shadow: 0 0 15px rgba(243, 156, 18, 0.3);
        }

        #connectDotsControls {
            display: flex;
            align-items: center;
            justify-content: space-between;
  gap: 20px;
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            backdrop-filter: blur(5px);
        }

        #gridSizeSelect {
            padding: 8px 15px;
            border-radius: 8px;
            background: rgba(243, 156, 18, 0.1);
            border: 1px solid rgba(243, 156, 18, 0.3);
            color: #f39c12;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        #gridSizeSelect:hover {
            background: rgba(243, 156, 18, 0.2);
        }

        #connectDotsStart {
            padding: 10px 25px;
            font-size: 1.1rem;
            background: linear-gradient(135deg, #f39c12, #e67e22);
            border: none;
            border-radius: 25px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        #connectDotsStart:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(243, 156, 18, 0.3);
        }

        .score-display {
            font-size: 1.3rem;
            color: #f39c12;
            text-shadow: 0 0 10px rgba(243, 156, 18, 0.3);
        }

        .game-board-container {
            position: relative;
            width: 100%;
            max-width: 500px;
            aspect-ratio: 1;
  margin: 0 auto;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
        }

        #connectDotsBoard {
            display: grid;
            gap: 2px;
  width: 100%;
  height: 100%;
            position: relative;
            z-index: 2;
        }

        #connectDotsLines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
            transform-origin: top left;
        }

        .temp-line, .permanent-line {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            transform-origin: top left;
        }

        svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            shape-rendering: geometricPrecision;
        }

        path {
            vector-effect: non-scaling-stroke;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        /* Grid and Cell Styles */
        #connectDotsBoard {
            display: grid;
            gap: 2px;
            width: 100%;
            height: 100%;
            position: relative;
            z-index: 2;
            background: rgba(255, 255, 255, 0.05);
  border-radius: 10px;
            padding: 10px;
        }

        .grid-cell {
            background: rgba(255, 255, 255, 0.03);
            border-radius: 4px;
            position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
            aspect-ratio: 1;
            padding: 5px;
        }

        .grid-cell:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        /* Dot Styles - Increased size */
        .dot {
            width: 75%;  /* Increased from 24px to 75% of cell */
            height: 75%; /* Makes dot cover ~60% of cell area */
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.2s ease-out, box-shadow 0.2s ease-out;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
            border: 3px solid rgba(255, 255, 255, 0.3);
            position: relative;
        }

        .dot::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 30%;  /* Adjusted inner circle size */
            height: 30%;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            opacity: 0;
            transition: all 0.2s ease;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .dot {
                width: 70%;
                height: 70%;
                border-width: 2px;
            }
        }

        @media (max-width: 480px) {
            .dot {
                width: 65%;
                height: 65%;
                border-width: 2px;
            }
        }

        .dot:hover {
            transform: scale(1.1);
            box-shadow: 0 0 20px currentColor;
        }

        .dot:hover::after {
            opacity: 1;
        }

        .dot.selected {
            transform: scale(1.2);
            box-shadow: 0 0 25px currentColor;
            border-color: white;
        }

        .dot.selected::after {
            opacity: 1;
            width: 10px;
            height: 10px;
        }

        @keyframes dotPulse {
            0% {
                transform: scale(1);
                box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
            }
            50% {
                transform: scale(1.1);
                box-shadow: 0 0 20px currentColor;
            }
            100% {
                transform: scale(1);
                box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
            }
        }

        /* Line Styles */
        .connection-line {
            position: absolute;
            height: 8px; /* Increased from 4px */
            transform-origin: left center;
            border-radius: 4px; /* Increased to match height */
            pointer-events: none;
            transition: all 0.1s ease-out;
        }

        .connection-line.temp-line {
            opacity: 0.6;
            filter: brightness(1.2);
            box-shadow: 0 0 12px currentColor; /* Increased shadow */
  z-index: 1;
            transition: all 0.15s ease-out;
            height: 8px; /* Ensure temp lines match permanent ones */
        }

        .connection-line.permanent {
            opacity: 1;
            box-shadow: 0 0 15px currentColor; /* Increased glow effect */
            z-index: 2;
            animation: connectLine 0.4s ease-out;
            height: 8px; /* Ensure consistent thickness */
        }

        /* Responsive adjustments for lines */
        @media (max-width: 768px) {
            .connection-line {
                height: 6px;
                border-radius: 3px;
            }
        }

        @media (max-width: 480px) {
            .connection-line {
                height: 5px;
                border-radius: 2.5px;
            }
        }

        .dot.highlight {
            transform: scale(1.15);
            transition: transform 0.15s ease-out;
        }

        .dot.connected {
            transform: scale(1.1);
            box-shadow: 0 0 15px currentColor;
            transition: all 0.3s ease-out;
        }

        /* Update the connection line styles */
        .connection-line {
            position: absolute;
            height: 8px; /* Increased from 4px */
            transform-origin: left center;
            border-radius: 4px; /* Increased to match height */
            opacity: 0.8;
            box-shadow: 0 0 12px rgba(0, 0, 0, 0.2);
            pointer-events: none;
            z-index: 2;
            animation: lineAppear 0.3s ease-out;
        }

        /* Update the lines container */
        #connectDotsLines {
            position: absolute;
  top: 0;
            left: 0;
  width: 100%;
  height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .connection-line.permanent {
            opacity: 1;
            box-shadow: 0 0 15px currentColor; /* Increased glow effect */
            animation: connectLine 0.3s ease-out;
            pointer-events: none;
            z-index: 2;
        }

        .dot.connected {
            transform: scale(1.1);
            border-color: white;
            box-shadow: 0 0 15px currentColor;
            pointer-events: none;
        }

        @keyframes connectLine {
            from {
                opacity: 0;
                transform: scaleX(0);
            }
            to {
                opacity: 1;
                transform: scaleX(1);
            }
        }

        .temp-line path {
            opacity: 0.6;
            filter: brightness(1.2);
            transition: all 0.1s ease-out;
            stroke-dasharray: none;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        .permanent-line path {
            opacity: 0;
            animation: connectLine 0.4s ease-out forwards;
        }

        @keyframes connectLine {
            0% {
                opacity: 0;
                stroke-dasharray: 0 1000;
            }
            100% {
                opacity: 1;
                stroke-dasharray: 1000 0;
            }
        }

        .temp-line.removing {
            opacity: 0;
        }

        .game-completion-popup {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .popup-content {
            background: #1e1e2f;
            padding: 2rem;
  border-radius: 10px;
            text-align: center;
            transform: translateY(20px);
            transition: transform 0.3s ease;
            animation: popupAppear 0.3s ease-out forwards;
        }

        @keyframes popupAppear {
            from {
                transform: translateY(20px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        /* Add these styles to your existing CSS */
        #snakeCanvas {
            background: #1a1a1a;
            border-radius: 10px;
            margin: 20px auto;
            display: block;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
        }

        .game-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 20px 0;
        }

        .score-display {
            font-size: 1.5rem;
            color: #f39c12;
            text-shadow: 0 0 10px rgba(243, 156, 18, 0.3);
        }

        #startSnakeGame {
  padding: 10px 20px;
            background: #2ecc71;
  color: white;
  border: none;
  border-radius: 5px;
  cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s ease;
        }

        #startSnakeGame:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(46, 204, 113, 0.3);
        }

        /* Add to your existing styles */
        #snakeCanvas {
            background: #1a1a1a;
            border-radius: 10px;
            margin: 20px auto;
            display: block;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
        }

        .game-stats {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 20px 0;
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
        }

        .score-container {
            font-size: 1.2rem;
            color: #f39c12;
            text-shadow: 0 0 10px rgba(243, 156, 18, 0.3);
        }

        #startSnakeGame {
            background: #2ecc71;
            color: white;
            border: none;
  padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s ease;
        }

        #startSnakeGame:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(46, 204, 113, 0.3);
        }

        /* Add to your existing style section */
        #snakeCanvas {
            background: #1a1a1a;
            border-radius: 10px;
            margin: 20px auto;
            display: block;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
        }

        .game-container {
            padding: 20px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            margin-top: 20px;
        }

        /* Add to your existing styles */
        .game-stats {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 20px 0;
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
        }

        .score-container {
            font-size: 1.2rem;
            color: #f39c12;
            text-shadow: 0 0 10px rgba(243, 156, 18, 0.3);
        }

        #startSnakeGame {
            background: #2ecc71;
  color: white;
  border: none;
            padding: 10px 20px;
  border-radius: 5px;
  cursor: pointer;
            transition: all 0.3s ease;
        }

        #startSnakeGame:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(46, 204, 113, 0.3);
        }

        .mobile-controls {
            display: none;
            flex-direction: column;
            align-items: center;
            margin-top: 20px;
        }

        .horizontal-controls {
            display: flex;
            gap: 20px;
            margin: 10px 0;
        }

        .control-btn {
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            border-radius: 10px;
            color: white;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .control-btn:active {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(0.95);
        }

        @media (max-width: 768px) {
            .mobile-controls {
                display: flex;
            }
        }
    </style>
</head>
<body>
    <div class="scroll-progress">
        <div class="scroll-progress-bar"></div>
    </div>
    <div id="particles-js"></div>
    <div id="app">
        <header class="header">
            <h1 class="logo animate__animated animate__fadeInDown">🎮 MiniGame Galaxy</h1>
        <nav class="nav animate__animated animate__fadeIn">
            <ul>
                    <li><a href="#home" class="nav-link">Home</a></li>
                    <li><a href="#games" class="nav-link">Games</a></li>
                    <li><a href="#about" class="nav-link">About</a></li>
            </ul>
        </nav>
        </header>

        <section id="home" class="hero section">
            <div id="hero-particles"></div>
            <div class="hero-content">
                <h2 class="hero-title">Play Fun Mini Games</h2>
                <p class="hero-text">Unleash fun and challenges with our collection of games. Completely free, no ads!</p>
                <a href="#games" class="btn">Explore Games</a>
            </div>
        </section>

        <section id="games" class="games-section section">
            <h2 class="section-title">Our Games</h2>
            <div class="game-list">
                <div class="game-item">
                    <h3>Tic Tac Toe</h3>
                    <p>Classic X's and O's game</p>
                    <button class="btn play-btn" data-game="ticTacToe">Play Now</button>
                </div>
                <div class="game-item">
                    <h3>2048</h3>
                    <p>Merge tiles to reach 2048!</p>
                    <button class="btn play-btn" data-game="game2048">Play Now</button>
                </div>
                <div class="game-item">
                    <h3>Memory Match</h3>
                    <p>Find matching pairs of cards</p>
                    <button class="btn play-btn" data-game="memoryMatch">Play Now</button>
                </div>
                <div class="game-item">
                    <h3>Connect Dots</h3>
                    <p>Connect all dots to complete the pattern</p>
                    <button class="btn play-btn" data-game="connectDots">Play Now</button>
                </div>
                <!-- Add this inside the game-list div, next to other game-items -->
                <div class="game-item animate__animated animate__fadeIn">
                    <h3>Snake Game</h3>
                    <p>Classic Snake: Navigate, eat food, and grow longer without hitting walls or yourself!</p>
                    <button class="btn play-btn" data-game="snakeGame">Play Now</button>
                </div>
            </div>
        </section>

        <section id="about" class="about-section section">
            <div class="about-content">
                <h2 class="section-title">About MiniGame Galaxy</h2>
                <div class="about-grid">
                    <div class="about-card">
                        <div class="card-icon">🎮</div>
                        <h3>Our Mission</h3>
                        <p>Creating fun, accessible games that bring joy to everyone. No ads, no payments, just pure entertainment!</p>
                    </div>
                    <div class="about-card">
                        <div class="card-icon">🌟</div>
                        <h3>Features</h3>
                        <p>Classic games reimagined with modern touches. Simple controls, engaging gameplay, and endless fun.</p>
                    </div>
                    <div class="about-card">
                        <div class="card-icon">🎯</div>
                        <h3>Why Choose Us</h3>
                        <p>Free forever, no hidden costs. Play instantly in your browser with no downloads required.</p>
                    </div>
                    <div class="about-card">
                        <div class="card-icon">🚀</div>
                        <h3>Future Plans</h3>
                        <p>More games coming soon! We're constantly working on new and exciting additions to our collection.</p>
                    </div>
                </div>
                <div class="about-footer">
                    <div class="stats">
                        <div class="stat-item">
                            <span class="stat-number">3+</span>
                            <span class="stat-label">Games</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-number">100%</span>
                            <span class="stat-label">Free</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-number">24/7</span>
                            <span class="stat-label">Available</span>
                        </div>
                    </div>
                    <div class="social-links">
                        <a href="#" class="social-link">🌐 Website</a>
                        <a href="#" class="social-link">📧 Contact</a>
                        <a href="#" class="social-link">💬 Feedback</a>
                    </div>
                </div>
            </div>
        </section>

        <!-- Footer Section -->
        <footer class="footer">
            <p>&copy; 2024 MiniGame Galaxy | Designed with ❤️ for gamers.</p>
            <p>Follow us on:</p>
            <div class="social-links">
                <a href="https://www.linkedin.com/in/yash-jain-03859b313/" target="_blank">Linkedin</a> |
                <a href="https://github.com/Yash1118Jain" target="_blank">Github</a> |
                <a href="https://www.instagram.com/yash_jain_1911" target="_blank">Instagram</a>
            </div>
        </footer>
    </div>

    <!-- Game Modals -->
    <!-- Tic Tac Toe Modal -->
<div id="ticTacToeModal" class="modal">
    <div class="modal-content">
            <button class="close-btn">&times;</button>
        <h2>Tic Tac Toe</h2>
            <div class="game-mode-select">
        <select id="mode">
            <option value="player-vs-player">Player vs Player</option>
            <option value="player-vs-computer">Player vs Computer</option>
        </select>
            </div>
            <div id="ticTacToeBoard" class="game-board">
            <div class="cell" data-cell-index="0"></div>
            <div class="cell" data-cell-index="1"></div>
            <div class="cell" data-cell-index="2"></div>
            <div class="cell" data-cell-index="3"></div>
            <div class="cell" data-cell-index="4"></div>
            <div class="cell" data-cell-index="5"></div>
            <div class="cell" data-cell-index="6"></div>
            <div class="cell" data-cell-index="7"></div>
            <div class="cell" data-cell-index="8"></div>
        </div>
            <div id="gameResult" class="game-result">
                <div class="result-content">
                    <h2 class="winner-text"></h2>
                    <button class="btn rematch-btn">Play Again</button>
    </div>
</div>
            <button id="restartGameBtn" class="btn">Restart Game</button>
                </div>
                </div>
                
    <!-- 2048 Modal -->
    <div id="game2048Modal" class="modal">
        <div class="modal-content">
            <button class="close-btn">&times;</button>
            <h2>2048</h2>
            <div class="game-settings">
                <label for="gridSize">Grid Size:</label>
                <select id="gridSize">
                    <option value="4">4 x 4</option>
                    <option value="5">5 x 5</option>
                    <option value="6">6 x 6</option>
                    <option value="7">7 x 7</option>
                </select>
                </div>
            <div id="game2048-score-panel">
                <span>Score: <span id="game2048-score">0</span></span>
                <span>High Score: <span id="game2048-high-score">0</span></span>
                </div>
            <div id="game2048-board" class="game-board"></div>
            <div id="game2048Result" class="game-result">
                <div class="result-content">
                    <h2 class="result-title"></h2>
                    <div class="score-info">
                        <p class="final-score"></p>
                        <p class="high-score-text"></p>
                </div>
                    <div class="result-buttons">
                        <button class="btn rematch-btn">Play Again</button>
                        <button class="btn change-size-btn">Change Grid Size</button>
            </div>
                </div>
                </div>
            <button id="game2048-restart-btn" class="btn">Restart Game</button>
                </div>
            </div>
    
    <!-- Memory Match Modal -->
    <div id="memoryMatchModal" class="modal">
    <div class="modal-content">
            <button class="close-btn">&times;</button>
            <h2>Memory Match</h2>
            <div id="memoryStats">
                <span id="memoryMoves">Moves: 0</span>
                <span id="memoryTimer">Time: 0:00</span>
            </div>
            <div id="memoryBoard"></div>
            <button id="memoryRestartBtn" class="btn">Restart Game</button>
        </div>
    </div>
    
    <!-- Connect Dots Modal -->
<div id="connectDotsModal" class="modal">
    <div class="modal-content">
            <button class="close-btn">&times;</button>
            <h2>Connect Dots</h2>
            
            <div class="game-container">
                <div id="connectDotsControls" class="game-controls">
                    <select id="gridSizeSelect">
                        <option value="4">4x4</option>
                        <option value="5">5x5</option>
                        <option value="6" selected>6x6</option>
                        <option value="7">7x7</option>
                    </select>
                    <button id="connectDotsStart" class="game-btn">Start</button>
                    <div class="score-display">
                        <span>Score: <span id="connectDotsScore">0</span></span>
        </div>
            </div>

                <div class="game-board-container">
                    <div id="connectDotsBoard" class="dots-board"></div>
                    <div id="connectDotsLines" class="lines-container"></div>
        </div>
    </div>
</div>

    <!-- Add this after your other game modals -->
    <div id="snakeGameModal" class="modal">
    <div class="modal-content">
            <button class="close-btn">&times;</button>
            <h2>Snake Game</h2>
            <div class="game-stats">
                <div class="score-container">
                    <div>Score: <span id="snakeScore">0</span></div>
                    <div>High Score: <span id="snakeHighScore">0</span></div>
        </div>
                <button id="startSnakeGame" class="btn">Start Game</button>
    </div>
            <canvas id="snakeCanvas" width="400" height="400"></canvas>
            <div class="mobile-controls">
                <button class="control-btn up">↑</button>
                <div class="horizontal-controls">
                    <button class="control-btn left">←</button>
                    <button class="control-btn right">→</button>
</div>
                <button class="control-btn down">↓</button>
    </div>
</div>
    </div>

    <script>
    // Modal handling
    const modals = {
        ticTacToe: document.getElementById('ticTacToeModal'),
        game2048: document.getElementById('game2048Modal'),
        memoryMatch: document.getElementById('memoryMatchModal'),
        connectDots: document.getElementById('connectDotsModal'),
        snakeGame: document.getElementById('snakeGameModal')
    };

    // Audio handling
    const gameAudios = {
        ticTacToe: new Audio('https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3'),
        game2048: new Audio('https://www.soundhelix.com/examples/mp3/SoundHelix-Song-2.mp3'),
        memoryMatch: new Audio('https://www.soundhelix.com/examples/mp3/SoundHelix-Song-3.mp3'),
        connectDots: new Audio('https://www.soundhelix.com/examples/mp3/SoundHelix-Song-4.mp3'),
        snakeGame: new Audio('https://www.soundhelix.com/examples/mp3/SoundHelix-Song-5.mp3')
    };

    // Initialize audio
    Object.values(gameAudios).forEach(audio => {
        audio.load();
        audio.volume = 0.3;
        audio.loop = true;
    });

    // Game initialization
    function playGame(game) {
        // Stop all audio and close all modals
        Object.values(gameAudios).forEach(audio => audio.pause());
        Object.values(modals).forEach(modal => modal.classList.remove('active'));

        // Open selected game modal and play audio
        const modal = modals[game];
        if (modal) {
            modal.classList.add('active');
            const audio = gameAudios[game];
            if (audio) {
                audio.currentTime = 0;
                audio.play().catch(error => console.error('Audio play error:', error));
            }
        }

        // Initialize the specific game
        switch(game) {
            case 'ticTacToe': TicTacToe.init(); break;
            case 'game2048': Game2048.init(); break;
            case 'memoryMatch': MemoryMatch.init(); break;
            case 'connectDots': ConnectDots.init(); break;
            case 'snakeGame': SnakeGame.init(); break;
        }
    }

    function closeModal(game) {
        const modal = modals[game];
        if (modal) {
            modal.classList.remove('active');
            const audio = gameAudios[game];
            if (audio) {
                audio.pause();
                audio.currentTime = 0;
            }
        }
    }

    // Tic Tac Toe Game Logic
    const TicTacToe = {
        currentPlayer: 'X',
        gameActive: true,
        gameMode: 'player-vs-player',
        board: ['', '', '', '', '', '', '', '', ''],
        winPatterns: [
            { cells: [0, 1, 2], type: 'horizontal', class: 'row-0' },
            { cells: [3, 4, 5], type: 'horizontal', class: 'row-1' },
            { cells: [6, 7, 8], type: 'horizontal', class: 'row-2' },
            { cells: [0, 3, 6], type: 'vertical', class: 'col-0' },
            { cells: [1, 4, 7], type: 'vertical', class: 'col-1' },
            { cells: [2, 5, 8], type: 'vertical', class: 'col-2' },
            { cells: [0, 4, 8], type: 'diagonal', class: 'diagonal-1' },
            { cells: [2, 4, 6], type: 'diagonal', class: 'diagonal-2' }
        ],

        init() {
            this.currentPlayer = 'X';
            this.gameActive = true;
            this.board = ['', '', '', '', '', '', '', '', ''];
            this.gameMode = document.getElementById('mode').value;
            this.renderBoard();
            this.removeVictoryLine();
            this.hideGameResult();
            this.addEventListeners();
        },

        addEventListeners() {
            // Clear previous event listeners
            const cells = document.querySelectorAll('.cell');
            cells.forEach(cell => {
                cell.replaceWith(cell.cloneNode(true));
            });

            // Add new event listeners
            document.querySelectorAll('.cell').forEach(cell => {
                cell.addEventListener('click', (e) => this.handleCellClick(e));
            });

            document.getElementById('mode').addEventListener('change', () => this.init());
            document.getElementById('restartGameBtn').addEventListener('click', () => this.init());

            // Add rematch button listener
            const rematchBtn = document.querySelector('.rematch-btn');
            if (rematchBtn) {
                rematchBtn.addEventListener('click', () => {
                this.init();
            });
            }
        },

        handleCellClick(e) {
            const index = parseInt(e.target.dataset.cellIndex);
            
            // Check if the move is valid and it's player's turn
            if (this.board[index] === '' && 
                this.gameActive && 
                (this.gameMode === 'player-vs-player' || this.currentPlayer === 'X')) {
                this.makeMove(index);
            }
        },

        makeMove(index) {
            if (!this.gameActive || this.board[index] !== '') return;

            this.board[index] = this.currentPlayer;
            this.renderBoard();

            if (this.checkWinner()) {
                this.gameActive = false;
                const winMessage = this.gameMode === 'player-vs-computer' && this.currentPlayer === 'O' 
                    ? 'Computer Wins!' 
                    : `Player ${this.currentPlayer} Wins!`;
                this.showGameResult(winMessage, this.currentPlayer);
                return;
            }

            if (this.board.every(cell => cell !== '')) {
                this.gameActive = false;
                this.showGameResult("It's a Draw! Play Again?");
                return;
            }

            this.currentPlayer = this.currentPlayer === 'X' ? 'O' : 'X';

            if (this.gameMode === 'player-vs-computer' && this.currentPlayer === 'O' && this.gameActive) {
                setTimeout(() => {
                    this.makeComputerMove();
                }, 500);
            }
        },

        makeComputerMove() {
            if (!this.gameActive) return;

            let bestScore = -Infinity;
            let bestMove;

            // Find the best move
            for (let i = 0; i < this.board.length; i++) {
                if (this.board[i] === '') {
                    this.board[i] = 'O';
                    let score = this.minimax(this.board, 0, false);
                    this.board[i] = '';
                    if (score > bestScore) {
                        bestScore = score;
                        bestMove = i;
                    }
                }
            }

            // Make the move if one was found
            if (bestMove !== undefined) {
                this.board[bestMove] = 'O';
                this.renderBoard();
                
                if (this.checkWinner()) {
                    this.gameActive = false;
                    this.showGameResult('Computer Wins!', 'O');
                    return;
                }

                if (this.board.every(cell => cell !== '')) {
                    this.gameActive = false;
                    this.showGameResult("It's a Draw! Play Again?");
                    return;
                }

                this.currentPlayer = 'X';
            }
        },

        minimax(board, depth, isMaximizing) {
            let result = this.checkGameState();
            if (result !== null) {
                return result === 'O' ? 10 - depth :
                       result === 'X' ? depth - 10 :
                       0;
            }

            if (isMaximizing) {
                let bestScore = -Infinity;
                for (let i = 0; i < board.length; i++) {
                    if (board[i] === '') {
                        board[i] = 'O';
                        let score = this.minimax(board, depth + 1, false);
                        board[i] = '';
                        bestScore = Math.max(score, bestScore);
                    }
                }
                return bestScore;
            } else {
                let bestScore = Infinity;
                for (let i = 0; i < board.length; i++) {
                    if (board[i] === '') {
                        board[i] = 'X';
                        let score = this.minimax(board, depth + 1, true);
                        board[i] = '';
                        bestScore = Math.min(score, bestScore);
                    }
                }
                return bestScore;
            }
        },

        renderBoard() {
            document.querySelectorAll('.cell').forEach((cell, index) => {
                cell.textContent = this.board[index];
                cell.classList.remove('x', 'o');
                if (this.board[index]) {
                    cell.classList.add(this.board[index].toLowerCase());
                }
            });
        },

        removeVictoryLine() {
            const existingLine = document.querySelector('.victory-line');
            if (existingLine) {
                existingLine.remove();
            }
        },

        drawVictoryLine(pattern) {
            const board = document.getElementById('ticTacToeBoard');
            this.removeVictoryLine();
            const line = document.createElement('div');
            
            // Determine winner and set appropriate class
            const winner = this.currentPlayer;
            const winnerClass = winner === 'X' ? 'x-win' : 'o-win';
            
            line.className = `victory-line ${pattern.type} ${pattern.class} ${winnerClass}`;
            board.appendChild(line);
        },

        checkWinner() {
            for (let pattern of this.winPatterns) {
                const [a, b, c] = pattern.cells;
                if (this.board[a] && 
                    this.board[a] === this.board[b] && 
                    this.board[a] === this.board[c]) {
                    this.drawVictoryLine(pattern);
                    return true;
                }
            }
            return false;
        },

        checkGameState() {
            for (let pattern of this.winPatterns) {
                const [a, b, c] = pattern.cells;
                if (this.board[a] && 
                    this.board[a] === this.board[b] && 
                    this.board[a] === this.board[c]) {
                    return this.board[a];
                }
            }
            if (this.board.every(cell => cell !== '')) return 'tie';
            return null;
        },

        showGameResult(message, winner) {
            const resultDiv = document.getElementById('gameResult');
            const winnerText = resultDiv.querySelector('.winner-text');
            
            // Clear any existing classes
            winnerText.className = 'winner-text';
            
            // Set the message
            winnerText.textContent = message;
            
            // Add winner-specific class if there is a winner
            if (winner) {
                winnerText.classList.add(`${winner.toLowerCase()}-win`);
            }
            
            // Show the result box
            resultDiv.classList.add('active');
        },

        hideGameResult() {
            const resultDiv = document.getElementById('gameResult');
            if (resultDiv) {
            resultDiv.classList.remove('active');
            }
        }
    };

    // 2048 Game Implementation
    const Game2048 = {
        gridSize: 4,
        board: [],
        score: 0,
        highScore: 0,
        gameActive: true,

        init() {
            const gridSize = parseInt(document.getElementById('gridSize').value);
            this.gridSize = gridSize;
            this.board = Array(gridSize).fill().map(() => Array(gridSize).fill(0));
            this.score = 0;
            this.gameActive = true;
            this.loadHighScore();
            this.addInitialTiles();
            this.updateBoard();
            this.hideGameResult();
            this.setupEventListeners();
        },

        setupEventListeners() {
            // Remove old event listeners
            document.removeEventListener('keydown', this.handleKeyPress);
            
            // Add new event listener with bound context
            document.addEventListener('keydown', this.handleKeyPress.bind(this));

            // Grid size change listener - only when game is not active
            document.getElementById('gridSize').addEventListener('change', () => {
                if (!this.gameActive) {
                    this.init();
                }
            });

            // Restart button listener
            document.getElementById('game2048-restart-btn').addEventListener('click', () => {
                this.init();
            });

            // Add result box button listeners
            document.querySelector('.rematch-btn').addEventListener('click', () => {
                this.init();
            });

            document.querySelector('.change-size-btn').addEventListener('click', () => {
                this.hideGameResult();
                document.getElementById('gridSize').focus();
            });
        },

        handleKeyPress(event) {
            if (!this.gameActive) return;

            switch(event.key) {
                case 'ArrowUp':
                    event.preventDefault();
                    this.move('up');
                    break;
                case 'ArrowDown':
                    event.preventDefault();
                    this.move('down');
                    break;
                case 'ArrowLeft':
                    event.preventDefault();
                    this.move('left');
                    break;
                case 'ArrowRight':
                    event.preventDefault();
                    this.move('right');
                    break;
            }
        },

        loadHighScore() {
            // Load high score for specific grid size
            this.highScore = parseInt(localStorage.getItem(`2048HighScore_${this.gridSize}x${this.gridSize}`)) || 0;
            document.getElementById('game2048-high-score').textContent = this.highScore;
        },

        addInitialTiles() {
            this.addNewTile();
            this.addNewTile();
        },

        addNewTile() {
            const emptyCells = [];
            
            // Find all empty cells
            for (let i = 0; i < this.gridSize; i++) {
                for (let j = 0; j < this.gridSize; j++) {
                    if (this.board[i][j] === 0) {
                        emptyCells.push({ i, j });
                    }
                }
            }
            
            // Add new tile only if there are empty cells
            if (emptyCells.length > 0) {
                const { i, j } = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                // Always add a tile with value 2 (removing the 10% chance of 4)
                this.board[i][j] = 2;
            }
        },

        updateBoard() {
            const gameBoard = document.getElementById('game2048-board');
            gameBoard.innerHTML = '';
            
            // Update grid size class
            gameBoard.className = 'game-board';
            gameBoard.classList.add(`grid-${this.gridSize}`);
            
            document.getElementById('game2048-score').textContent = this.score;
            document.getElementById('game2048-high-score').textContent = this.highScore;

            for (let i = 0; i < this.gridSize; i++) {
                for (let j = 0; j < this.gridSize; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'game2048-cell';
                    const value = this.board[i][j];
                    
                    if (value !== 0) {
                        cell.classList.add(`tile-${value}`);
                        cell.textContent = value;
                    }
                    
                    gameBoard.appendChild(cell);
                }
            }
        },

        move(direction) {
            if (!this.gameActive) return;

            let moved = false;
            const newBoard = Array(this.gridSize).fill().map(() => Array(this.gridSize).fill(0));

            switch(direction) {
                case 'left':
                    // Move all numbers to the left
                    for (let i = 0; i < this.gridSize; i++) {
                        let currentPosition = 0;
                        // First move everything to the left
                        for (let j = 0; j < this.gridSize; j++) {
                            if (this.board[i][j] !== 0) {
                                newBoard[i][currentPosition] = this.board[i][j];
                                if (currentPosition !== j) moved = true;
                                currentPosition++;
                            }
                        }
                        // Then merge
                        for (let j = 0; j < this.gridSize - 1; j++) {
                            if (newBoard[i][j] !== 0 && newBoard[i][j] === newBoard[i][j + 1]) {
                                newBoard[i][j] *= 2;
                                this.score += newBoard[i][j];
                                // Shift everything else left
                                for (let k = j + 1; k < this.gridSize - 1; k++) {
                                    newBoard[i][k] = newBoard[i][k + 1];
                                }
                                newBoard[i][this.gridSize - 1] = 0;
                                moved = true;
                            }
                        }
                    }
                    break;

                case 'right':
                    // Move all numbers to the right
                    for (let i = 0; i < this.gridSize; i++) {
                        let currentPosition = this.gridSize - 1;
                        // First move everything to the right
                        for (let j = this.gridSize - 1; j >= 0; j--) {
                            if (this.board[i][j] !== 0) {
                                newBoard[i][currentPosition] = this.board[i][j];
                                if (currentPosition !== j) moved = true;
                                currentPosition--;
                            }
                        }
                        // Then merge
                        for (let j = this.gridSize - 1; j > 0; j--) {
                            if (newBoard[i][j] !== 0 && newBoard[i][j] === newBoard[i][j - 1]) {
                                newBoard[i][j] *= 2;
                                this.score += newBoard[i][j];
                                // Shift everything else right
                                for (let k = j - 1; k > 0; k--) {
                                    newBoard[i][k] = newBoard[i][k - 1];
                                }
                                newBoard[i][0] = 0;
                                moved = true;
                            }
                        }
                    }
                    break;

                case 'up':
                    // Move all numbers up
                    for (let j = 0; j < this.gridSize; j++) {
                        let currentPosition = 0;
                        // First move everything up
                        for (let i = 0; i < this.gridSize; i++) {
                            if (this.board[i][j] !== 0) {
                                newBoard[currentPosition][j] = this.board[i][j];
                                if (currentPosition !== i) moved = true;
                                currentPosition++;
                            }
                        }
                        // Then merge
                        for (let i = 0; i < this.gridSize - 1; i++) {
                            if (newBoard[i][j] !== 0 && newBoard[i][j] === newBoard[i + 1][j]) {
                                newBoard[i][j] *= 2;
                                this.score += newBoard[i][j];
                                // Shift everything else up
                                for (let k = i + 1; k < this.gridSize - 1; k++) {
                                    newBoard[k][j] = newBoard[k + 1][j];
                                }
                                newBoard[this.gridSize - 1][j] = 0;
                                moved = true;
                            }
                        }
                    }
                    break;

                case 'down':
                    // Move all numbers down
                    for (let j = 0; j < this.gridSize; j++) {
                        let currentPosition = this.gridSize - 1;
                        // First move everything down
                        for (let i = this.gridSize - 1; i >= 0; i--) {
                            if (this.board[i][j] !== 0) {
                                newBoard[currentPosition][j] = this.board[i][j];
                                if (currentPosition !== i) moved = true;
                                currentPosition--;
                            }
                        }
                        // Then merge
                        for (let i = this.gridSize - 1; i > 0; i--) {
                            if (newBoard[i][j] !== 0 && newBoard[i][j] === newBoard[i - 1][j]) {
                                newBoard[i][j] *= 2;
                                this.score += newBoard[i][j];
                                // Shift everything else down
                                for (let k = i - 1; k > 0; k--) {
                                    newBoard[k][j] = newBoard[k - 1][j];
                                }
                                newBoard[0][j] = 0;
                                moved = true;
                            }
                        }
                    }
                    break;
            }

            if (moved) {
                this.board = newBoard;
                this.addNewTile();
                this.updateBoard();
                
                // Update high score if current score is higher
                if (this.score > this.highScore) {
                    this.highScore = this.score;
                    localStorage.setItem(`2048HighScore_${this.gridSize}x${this.gridSize}`, this.highScore);
                    document.getElementById('game2048-high-score').textContent = this.highScore;
                }
                
                // Check for game over
                if (this.checkGameOver()) {
                    this.gameActive = false;
                    this.showGameResult(true);
                }
            }
        },

        mergeArray(arr) {
            const result = [];
            for (let i = 0; i < arr.length; i++) {
                if (i < arr.length - 1 && arr[i] === arr[i + 1]) {
                    result.push(arr[i] * 2);
                    this.score += arr[i] * 2;
                    i++;
                } else {
                    result.push(arr[i]);
                }
            }
            return result;
        },

        canMove() {
            // Check for empty cells
            for (let i = 0; i < this.gridSize; i++) {
                for (let j = 0; j < this.gridSize; j++) {
                    if (this.board[i][j] === 0) return true;
                }
            }

            // Check for possible merges
            for (let i = 0; i < this.gridSize; i++) {
                for (let j = 0; j < this.gridSize; j++) {
                    const current = this.board[i][j];
                    if ((j < this.gridSize - 1 && current === this.board[i][j + 1]) ||
                        (i < this.gridSize - 1 && current === this.board[i + 1][j])) {
                        return true;
                    }
                }
            }
            return false;
        },

        checkGameOver() {
            // Check if there are any empty cells
            for (let i = 0; i < this.gridSize; i++) {
                for (let j = 0; j < this.gridSize; j++) {
                    if (this.board[i][j] === 0) return false;
                }
            }

            // Check if any adjacent cells have the same value
            for (let i = 0; i < this.gridSize; i++) {
                for (let j = 0; j < this.gridSize; j++) {
                    const current = this.board[i][j];
                    
                    // Check right
                    if (j < this.gridSize - 1 && current === this.board[i][j + 1]) return false;
                    
                    // Check down
                    if (i < this.gridSize - 1 && current === this.board[i + 1][j]) return false;
                }
            }

            return true; // No moves left
        },

        checkWin() {
            for (let row of this.board) {
                if (row.includes(2048)) return true;
            }
            return false;
        },

        showGameResult(isGameOver) {
            const resultDiv = document.getElementById('game2048Result');
            const resultTitle = resultDiv.querySelector('.result-title');
            const finalScore = resultDiv.querySelector('.final-score');
            const highScoreText = resultDiv.querySelector('.high-score-text');
            
            const isNewHighScore = this.score > this.highScore;
            
            let message = isGameOver ? 
                (isNewHighScore ? 
                    `🎉 New ${this.gridSize}x${this.gridSize} High Score! 🎉` : 
                    `Game Over - ${this.gridSize}x${this.gridSize} Grid`) :
                `You've Won the ${this.gridSize}x${this.gridSize} Game!`;

            resultTitle.textContent = message;
            finalScore.textContent = `Final Score: ${this.score}`;
            highScoreText.textContent = `High Score: ${this.highScore}`;

            resultDiv.classList.add('active');
        },

        hideGameResult() {
            const resultDiv = document.getElementById('game2048Result');
            if (resultDiv) {
                resultDiv.classList.remove('active');
                resultDiv.classList.remove('new-highscore');
            }
        }
    };

    // Initialize the game
    Game2048.init();

    // Initialize particles.js with enhanced configuration
    function initParticles() {
        particlesJS("particles-js", {
            particles: {
                number: {
                    value: 100,
                    density: {
                        enable: true,
                        value_area: 800
                    }
                },
                color: {
                    value: ["#f39c12", "#e74c3c", "#3498db", "#2ecc71", "#9b59b6"]
                },
                shape: {
                    type: ["circle", "triangle", "star"],
                    stroke: {
                        width: 0,
                        color: "#000000"
                    },
                    polygon: {
                        nb_sides: 5
                    },
                    star: {
                        nb_sides: 5,
                        inner_radius: 0.5,
                        outer_radius: 1
                    }
                },
                opacity: {
                    value: 0.6,
                    random: true,
                    anim: {
                        enable: true,
                        speed: 1,
                        opacity_min: 0.1,
                        sync: false
                    }
                },
                size: {
                    value: 4,
                    random: true,
                    anim: {
                        enable: true,
                        speed: 4,
                        size_min: 0.3,
                        sync: false
                    }
                },
                line_linked: {
                    enable: true,
                    distance: 150,
                    color: "#f39c12",
                    opacity: 0.4,
                    width: 1,
                    shadow: {
                        enable: true,
                        blur: 5,
                        color: "#f39c12"
                    }
                },
                move: {
                    enable: true,
                    speed: 3,
                    direction: "none",
                    random: true,
                    straight: false,
                    out_mode: "bounce",
                    bounce: false,
                    attract: {
                        enable: true,
                        rotateX: 600,
                        rotateY: 1200
                    }
                }
            },
            interactivity: {
                detect_on: "canvas",
                events: {
                    onhover: {
                        enable: true,
                        mode: ["grab", "bubble"]
                    },
                    onclick: {
                        enable: true,
                        mode: "push"
                    },
                    resize: true
                },
                modes: {
                    grab: {
                        distance: 140,
                        line_linked: {
                            opacity: 1,
                            color: "#f39c12"
                        }
                    },
                    bubble: {
                        distance: 200,
                        size: 12,
                        duration: 2,
                        opacity: 0.8,
                        speed: 3
                    },
                    push: {
                        particles_nb: 4
                    },
                    remove: {
                        particles_nb: 2
                    }
                }
            },
            retina_detect: true,
            background: {
                color: "#111",
                image: "",
                position: "50% 50%",
                repeat: "no-repeat",
                size: "cover"
            }
        });
    }

    // Initialize everything when the DOM is loaded
    document.addEventListener('DOMContentLoaded', () => {
        initParticles();

        // Add click handlers for play buttons
        document.querySelectorAll('.play-btn').forEach(btn => {
            const game = btn.dataset.game;
            if (game) {
                btn.addEventListener('click', () => playGame(game));
            }
        });

        // Add click handlers for close buttons
        document.querySelectorAll('.close-btn').forEach(btn => {
            const modalId = btn.closest('.modal').id;
            const game = modalId.replace('Modal', '');
            btn.addEventListener('click', () => closeModal(game));
        });

        // Handle clicking outside modal
        window.addEventListener('click', (e) => {
            Object.entries(modals).forEach(([game, modal]) => {
                if (modal && e.target === modal) {
                    closeModal(game);
                }
            });
        });

        // Initialize Tic Tac Toe
        TicTacToe.init();

        // Smooth scroll for navigation links
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const targetId = this.getAttribute('href');
                const targetSection = document.querySelector(targetId);
                
                // Remove active class from all nav links
                document.querySelectorAll('.nav-link').forEach(link => {
                    link.classList.remove('active');
                });
                
                // Add active class to clicked link
                this.classList.add('active');

                // Smooth scroll to target
                targetSection.scrollIntoView({
                    behavior: 'smooth'
                });
        });
    });

        // Intersection Observer for section animations
        const sections = document.querySelectorAll('.section');
        const navLinks = document.querySelectorAll('.nav-link');

        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    entry.target.classList.add('active');
                    
                    // Update active nav link
                    const id = entry.target.getAttribute('id');
                    navLinks.forEach(link => {
                        if (link.getAttribute('href') === `#${id}`) {
                            link.classList.add('active');
                        } else {
                            link.classList.remove('active');
                        }
                    });
                }
            });
        }, {
            threshold: 0.3
        });
    
        sections.forEach(section => {
            observer.observe(section);
        });
    
        // Add floating animation to logo
        document.querySelector('.logo').classList.add('floating');

        // Scroll Progress Bar
        const progressBar = document.querySelector('.scroll-progress-bar');
        window.addEventListener('scroll', () => {
            const winScroll = document.body.scrollTop || document.documentElement.scrollTop;
            const height = document.documentElement.scrollHeight - document.documentElement.clientHeight;
            const scrolled = (winScroll / height) * 100;
            progressBar.style.width = scrolled + '%';
        });

        // Interactive Game Items
        document.querySelectorAll('.game-item').forEach(item => {
            item.addEventListener('mousemove', (e) => {
                const rect = item.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                item.style.setProperty('--mouse-x', `${x}px`);
                item.style.setProperty('--mouse-y', `${y}px`);
            });
        });

        // Loading Animation
    function showLoading() {
        const loader = document.createElement('div');
        loader.className = 'loading';
        loader.innerHTML = '<div class="loading-spinner"></div>';
        document.body.appendChild(loader);
        return loader;
    }

    function hideLoading(loader) {
        if (loader) {
            loader.remove();
        }
    }
    });

    function startSnakeGame() {
    document.getElementById('startSnakeGame').textContent = 'Restart';
    // Clear canvas and reset game variables
    resetGame();
    // Start the game loop
    requestAnimationFrame(gameLoop);
}

function resetGame() {
    // Initialize snake, score, and other variables
    snake = [{ x: 10, y: 10 }];
    direction = { x: 1, y: 0 };
    score = 0;
    updateScore();
}

function gameLoop() {
    // Clear canvas and draw snake
    clearCanvas();
    drawSnake();
    moveSnake();
    
    if (checkCollision()) {
        alert('Game Over');
        return;
    }
    
    requestAnimationFrame(gameLoop);
}
    document.addEventListener('scroll', () => {
        const header = document.querySelector('.header');
        if (window.scrollY > 50) {
            header.classList.add('scrolled');
    } else {
            header.classList.remove('scrolled');
        }
    });

    const MemoryMatch = {
        cards: [],
        flippedCards: [],
        matchedPairs: 0,
        isLocked: false,
        moves: 0,
        gameStarted: false,
        timer: 0,
        timerInterval: null,

        init() {
            this.cards = [];
            this.flippedCards = [];
            this.matchedPairs = 0;
            this.isLocked = false;
            this.moves = 0;
            this.gameStarted = false;
            this.timer = 0;
            if (this.timerInterval) clearInterval(this.timerInterval);
            
            const symbols = ['🌟', '🎮', '🎲', '🎯', '🎨', '🎭', '🎪', '🎰'];
            const deck = [...symbols, ...symbols];
            this.shuffleDeck(deck);
            this.createBoard(deck);
            this.updateStats();
            this.setupEventListeners();
        },

        setupEventListeners() {
            // Remove old event listeners
            const restartBtn = document.getElementById('memoryRestartBtn');
            const newRestartBtn = restartBtn.cloneNode(true);
            restartBtn.parentNode.replaceChild(newRestartBtn, restartBtn);

            // Add new event listener
            newRestartBtn.addEventListener('click', () => {
                this.init();
            });

            // Add modal open listener if not already added
            const modalBtn = document.getElementById('memoryMatchBtn');
            modalBtn.removeEventListener('click', this.init.bind(this));
            modalBtn.addEventListener('click', () => {
                setTimeout(() => {
                    this.init();
                }, 100);
            });
        },

        shuffleDeck(deck) {
            for (let i = deck.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [deck[i], deck[j]] = [deck[j], deck[i]];
            }
        },

        createBoard(deck) {
            const gameBoard = document.getElementById('memoryBoard');
            gameBoard.innerHTML = '';
            
            deck.forEach((symbol, index) => {
            const card = document.createElement('div');
                card.className = 'memory-card';
            card.dataset.index = index;
                card.dataset.symbol = symbol;
                
                card.innerHTML = `
                    <div class="card-inner">
                        <div class="card-front"></div>
                        <div class="card-back">${symbol}</div>
                    </div>
                `;
                
                card.addEventListener('click', () => this.flipCard(card));
                gameBoard.appendChild(card);
            });
        },

        flipCard(card) {
            if (this.isLocked || this.flippedCards.includes(card) || card.classList.contains('matched')) {
        return;
    }
    
            if (!this.gameStarted) {
                this.startTimer();
                this.gameStarted = true;
            }

            card.classList.add('flipped');
            this.flippedCards.push(card);

            if (this.flippedCards.length === 2) {
                this.moves++;
                this.updateStats();
                this.isLocked = true;
                this.checkMatch();
            }
        },

        checkMatch() {
            const [card1, card2] = this.flippedCards;
            const match = card1.dataset.symbol === card2.dataset.symbol;

            if (match) {
                this.handleMatch(card1, card2);
            } else {
                this.handleMismatch(card1, card2);
            }
        },

        handleMatch(card1, card2) {
                card1.classList.add('matched');
                card2.classList.add('matched');
            this.matchedPairs++;
            this.resetTurn();

            if (this.matchedPairs === 8) {
                this.endGame();
            }
        },

        handleMismatch(card1, card2) {
            setTimeout(() => {
                card1.classList.remove('flipped');
                card2.classList.remove('flipped');
                this.resetTurn();
        }, 1000);
        },

        resetTurn() {
            this.flippedCards = [];
            this.isLocked = false;
        },

        startTimer() {
            this.timerInterval = setInterval(() => {
                this.timer++;
                this.updateStats();
            }, 1000);
        },

        updateStats() {
            document.getElementById('memoryMoves').textContent = `Moves: ${this.moves}`;
            document.getElementById('memoryTimer').textContent = `Time: ${this.formatTime(this.timer)}`;
        },

        formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
        },

        endGame() {
            clearInterval(this.timerInterval);
            const finalTime = this.formatTime(this.timer);
            setTimeout(() => {
                alert(`Congratulations! You won!\nMoves: ${this.moves}\nTime: ${finalTime}`);
            }, 500);
        }
    };

    // Remove these from the global scope if they exist
    document.querySelectorAll('script').forEach(script => {
        if (script.textContent.includes('memoryRestartBtn')) {
            script.remove();
        }
    });
    const ConnectDots = {
    gridSize: 6,
    dots: [],
    selectedDot: null,
    lines: [],
    gameActive: false,
    score: 0,
    moveCount: 0,
    dotPairs: [],
    colors: [
        '#e74c3c', '#3498db', '#2ecc71', '#f1c40f',
        '#9b59b6', '#e67e22', '#1abc9c', '#34495e'
    ],
    isDragging: false,
    tempLine: null,
    currentPath: [],
    // Add covered tiles tracking
    coveredTiles: [],

    init() {
        this.resetGame();
        this.setupEventListeners();
        this.gridSize = parseInt(document.getElementById('gridSizeSelect').value);
        // Initialize covered tiles array
        this.coveredTiles = Array.from({ length: this.gridSize }, 
            () => Array(this.gridSize).fill(false)
        );
        this.createBoard();
        this.generateDotPairs();
    },

    resetGame() {
        this.dots = [];
        this.lines = [];
        this.dotPairs = [];
        this.selectedDot = null;
        this.gameActive = false;
        this.score = 0;
        this.moveCount = 0;
        this.updateScore();
        this.clearBoard();
        // Reset covered tiles
        this.coveredTiles = Array.from({ length: this.gridSize }, 
            () => Array(this.gridSize).fill(false)
        );
    },

    startGame() {
        this.resetGame();
        this.gameActive = true;
        this.gridSize = parseInt(document.getElementById('gridSizeSelect').value);
        this.createBoard();
        this.generateDotPairs();
        document.getElementById('connectDotsStart').textContent = 'Restart';
    },

    clearBoard() {
        document.getElementById('connectDotsBoard').innerHTML = '';
        document.getElementById('connectDotsLines').innerHTML = '';
    },

    createBoard() {
        const board = document.getElementById('connectDotsBoard');
        if (!board) {
            console.error('Board element not found!');
                        return;
                    }
        
        board.style.gridTemplateColumns = `repeat(${this.gridSize}, 1fr)`;
        board.innerHTML = ''; // Clear existing grid cells

        // Create grid cells
        for (let i = 0; i < this.gridSize; i++) {
            for (let j = 0; j < this.gridSize; j++) {
                const cell = document.createElement('div');
                cell.className = 'grid-cell';
                cell.dataset.row = i;
                cell.dataset.col = j;
                board.appendChild(cell);
            }
        }
    },

    generateDotPairs() {
        // Reset game state
        this.dots = [];
        this.dotPairs = [];
        this.lines = [];

        const colors = [
            '#e74c3c', '#3498db', '#2ecc71', '#f1c40f',
            '#9b59b6', '#e67e22', '#1abc9c', '#34495e',
            '#d35400', '#2980b9', '#27ae60', '#f39c12',
            '#8e44ad', '#c0392b', '#16a085', '#2c3e50'
        ].sort(() => Math.random() - 0.5);

        // Create grid to track cell usage
        const grid = Array(this.gridSize).fill().map(() => 
            Array(this.gridSize).fill(null)
        );

        // Generate paths using backtracking
        const paths = this.generateValidPaths(grid);
        if (!paths) {
            // If generation fails, retry
            return this.generateDotPairs();
        }

        // Create dots from valid paths
        paths.forEach((path, index) => {
            const color = colors[index % colors.length];
            const start = path[0];
            const end = path[path.length - 1];

            // Create dots at path endpoints
            this.createDot(start.row, start.col, color, index);
            this.createDot(end.row, end.col, color, index);

            // Store path information
            this.dotPairs.push({
                id: index,
                color: color,
                dots: [start, end],
                path: path
            });

            // Mark path in grid
            path.forEach(point => {
                grid[point.row][point.col] = index;
            });
        });
    },

    generateValidPaths(grid) {
        const paths = [];
        const cellsToFill = new Set(
            Array(this.gridSize * this.gridSize)
                .fill()
                .map((_, i) => `${Math.floor(i / this.gridSize)},${i % this.gridSize}`)
        );

        while (cellsToFill.size > 0) {
            const path = this.findNextPath(grid, cellsToFill);
            if (!path) return null; // Failed to find valid path

            paths.push(path);
            // Remove path cells from cells to fill
            path.forEach(point => {
                cellsToFill.delete(`${point.row},${point.col}`);
            });
        }

        const SnakeGame = {
        canvas: null,
        ctx: null,
        snake: [],
        direction: 'right',
        nextDirection: 'right',
        gameLoop: null,
        cellSize: 20,
        gameActive: false,
        speed: 150,
        food: null,
        foodEmojis: ['🍎', '🍐', '🍊', '🍋', '🍇', '🍓', '🍒', '🍑', '🍍'],
        currentFoodEmoji: '',
        score: 0,
        highScore: localStorage.getItem('snakeHighScore') || 0,
        walls: [],
    shrubs: [],
    gridSize: null,

        generateFood() {
        const gridWidth = Math.floor(this.canvas.width / this.cellSize);
        const gridHeight = Math.floor(this.canvas.height / this.cellSize);
        
        do {
            this.food = {
                x: Math.floor(Math.random() * (gridWidth - 2)) + 1,
                y: Math.floor(Math.random() * (gridHeight - 2)) + 1
            };
        } while (this.snake.some(segment => 
            segment.x === this.food.x && segment.y === this.food.y
        ));

        // Select random emoji for food
        this.currentFoodEmoji = this.foodEmojis[
            Math.floor(Math.random() * this.foodEmojis.length)
        ];
    },

    drawFood() {
        if (!this.food) return;
        
        this.ctx.font = `${this.cellSize}px Arial`;
        this.ctx.textAlign = 'center';
        this.ctx.textBaseline = 'middle';
        
        const x = (this.food.x * this.cellSize) + (this.cellSize / 2);
        const y = (this.food.y * this.cellSize) + (this.cellSize / 2);
        
        this.ctx.fillText(
            this.currentFoodEmoji,
            x,
            y
        );
    },
        init() {
            this.canvas = document.getElementById('snakeCanvas');
            this.ctx = this.canvas.getContext('2d');
            
            // Set canvas size
            const modalContent = document.querySelector('#snakeGameModal .modal-content');
            const size = Math.min(modalContent.clientWidth - 40, 500);
            this.canvas.width = size;
            this.canvas.height = size;
            this.gridSize = Math.floor(this.canvas.width / this.cellSize);
        this.initializeWalls();
        this.generateShrubs(3); // Generate 3 shrubs
            this.setupControls();
            this.resetGame();
        },

        setupControls() {
            // Keyboard controls (Arrow keys and WASD)
            document.addEventListener('keydown', (e) => {
                if (!this.gameActive) return;
                
                switch(e.key) {
                    case 'ArrowUp':
                    case 'w':
                    case 'W':
                        if (this.direction !== 'down') this.nextDirection = 'up';
                        break;
                    case 'ArrowDown':
                    case 's':
                    case 'S':
                        if (this.direction !== 'up') this.nextDirection = 'down';
                        break;
                    case 'ArrowLeft':
                    case 'a':
                    case 'A':
                        if (this.direction !== 'right') this.nextDirection = 'left';
                        break;
                    case 'ArrowRight':
                    case 'd':
                    case 'D':
                        if (this.direction !== 'left') this.nextDirection = 'right';
                        break;
                }
                e.preventDefault();
            });

            // Mobile controls
            const mobileControls = document.querySelectorAll('.control-btn');
            mobileControls.forEach(btn => {
                btn.addEventListener('click', () => {
                    if (!this.gameActive) return;
                    
                    if (btn.classList.contains('up') && this.direction !== 'down') {
                        this.nextDirection = 'up';
                    } else if (btn.classList.contains('down') && this.direction !== 'up') {
                        this.nextDirection = 'down';
                    } else if (btn.classList.contains('left') && this.direction !== 'right') {
                        this.nextDirection = 'left';
                    } else if (btn.classList.contains('right') && this.direction !== 'left') {
                        this.nextDirection = 'right';
                    }
                });
            });

            // Start game button
            document.getElementById('startSnakeGame').addEventListener('click', () => {
                this.startGame();
            });
        },

        startGame() {
            this.resetGame();
            this.gameActive = true;
            this.gameLoop = setInterval(() => this.update(), this.speed);
            document.getElementById('startSnakeGame').textContent = 'Restart';
        },

        resetGame() {
            // Initialize snake in the middle of the canvas
            const centerX = Math.floor(this.canvas.width / (2 * this.cellSize));
            const centerY = Math.floor(this.canvas.height / (2 * this.cellSize));
            
            this.snake = [
                { x: centerX, y: centerY },
                { x: centerX - 1, y: centerY },
                { x: centerX - 2, y: centerY }
            ];
            
            this.direction = 'right';
            this.nextDirection = 'right';
            this.speed = 150;
            this.draw();
            this.score = 0;
            this.updateScore();
            this.generateFood();
            this.draw();
        },

        initializeWalls() {
        this.walls = [];
        // Create border walls
        for (let i = 0; i < this.gridSize; i++) {
            this.walls.push(
                {x: 0, y: i},                    // Left wall
                {x: this.gridSize - 1, y: i},    // Right wall
                {x: i, y: 0},                    // Top wall
                {x: i, y: this.gridSize - 1}     // Bottom wall
            );
        }
    },

    generateShrubs(count) {
        this.shrubs = [];
        for (let i = 0; i < count; i++) {
            let shrub;
            do {
                shrub = {
                    x: Math.floor(Math.random() * (this.gridSize - 4)) + 2,
                    y: Math.floor(Math.random() * (this.gridSize - 4)) + 2
                };
            } while (
                this.snake.some(segment => 
                    segment.x === shrub.x && segment.y === shrub.y
                ) ||
                this.shrubs.some(s => 
                    s.x === shrub.x && s.y === shrub.y
                )
            );
            this.shrubs.push(shrub);
        }
    },

    checkCollision(head) {
        // Check wall collision
        const wallCollision = this.walls.some(wall => 
            wall.x === head.x && wall.y === head.y
        );
        if (wallCollision) {
            this.gameOver('wall');
            return true;
        }

        // Check self collision
        const selfCollision = this.snake.some(segment => 
            segment.x === head.x && segment.y === head.y
        );
        if (selfCollision) {
            this.gameOver('self');
            return true;
        }

        // Check shrub collision
        const shrubCollision = this.shrubs.some(shrub => 
            shrub.x === head.x && shrub.y === head.y
        );
        if (shrubCollision) {
            this.hitShrub();
            return false; // Don't end game, just reset snake length
        }

        return false;
    },

    hitShrub() {
        // Reset snake to initial length but keep the head position
        const head = this.snake[0];
        this.snake = [head];
        this.speed = 150; // Reset speed
        
        // Visual feedback
        this.flashScreen('#2ecc71');
    },

    flashScreen(color) {
        this.ctx.fillStyle = color + '40'; // 40 for opacity
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    },

    gameOver(reason) {
        this.gameActive = false;
        clearInterval(this.gameLoop);
        
        // Play game over sound
        const gameOverSound = new Audio('data:audio/wav;base64,...'); // Add game over sound
        gameOverSound.play().catch(err => console.log('Audio play failed:', err));

        // Visual feedback
        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        this.ctx.fillStyle = '#fff';
        this.ctx.font = '30px Comic Sans MS';
        this.ctx.textAlign = 'center';
        
        const message = reason === 'wall' ? 'Hit the wall!' : 'Hit yourself!';
        this.ctx.fillText('Game Over!', this.canvas.width/2, this.canvas.height/2 - 30);
        this.ctx.fillText(message, this.canvas.width/2, this.canvas.height/2 + 10);
        
        document.getElementById('startSnakeGame').textContent = 'Play Again';
    },

        update() {
        if (!this.gameActive) return;

        this.direction = this.nextDirection;
        const head = { ...this.snake[0] };

        switch(this.direction) {
            case 'up': head.y--; break;
            case 'down': head.y++; break;
            case 'left': head.x--; break;
            case 'right': head.x++; break;
        }

        // Check collisions before updating snake position
        if (this.checkCollision(head)) return;

        // Check if snake ate food
        if (this.food && head.x === this.food.x && head.y === this.food.y) {
            // Play eat sound
            this.playEatSound();
            
            // Increase score
            this.score += 10;
            if (this.score > this.highScore) {
                this.highScore = this.score;
                localStorage.setItem('snakeHighScore', this.highScore);
            }
            this.updateScore();

            // Generate new food
            this.generateFood();

            // Increase speed
            if (this.speed > 50) {
                this.speed -= 2;
                clearInterval(this.gameLoop);
                this.gameLoop = setInterval(() => this.update(), this.speed);
            }
        } else {
            this.snake.pop(); // Remove tail only if food wasn't eaten
        }

        this.snake.unshift(head);
        this.draw();
    },
        draw() {
            // Clear canvas
            this.ctx.fillStyle = '#1a1a1a';
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Draw walls
        this.ctx.fillStyle = '#8B4513'; // Brown color for walls
        this.walls.forEach(wall => {
            this.ctx.fillRect(
                wall.x * this.cellSize,
                wall.y * this.cellSize,
                this.cellSize,
                this.cellSize
            );
        });

        // Draw shrubs
        this.ctx.fillStyle = '#006400'; // Dark green for shrubs
        this.shrubs.forEach(shrub => {
            this.ctx.fillRect(
                shrub.x * this.cellSize,
                shrub.y * this.cellSize,
                this.cellSize,
                this.cellSize
            );
        });

            // Draw snake
            this.snake.forEach((segment, index) => {
                // Snake head
                if (index === 0) {
                    this.drawSnakeHead(segment);
                } else {
                    // Snake body
                    this.ctx.fillStyle = '#2ecc71';
                    this.ctx.fillRect(
                        segment.x * this.cellSize,
                        segment.y * this.cellSize,
                        this.cellSize - 1,
                        this.cellSize - 1
                    );
                }
            });
                    // Draw food
        this.drawFood();
        },
        updateScore() {
        document.getElementById('snakeScore').textContent = this.score;
        document.getElementById('snakeHighScore').textContent = this.highScore;
    },

    playEatSound() {
        const eatSound = new Audio('data:audio/wav;base64,UklGRl9vT19XQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YU...'); // Add base64 audio data
        eatSound.volume = 0.3;
        eatSound.play().catch(err => console.log('Audio play failed:', err));
    },
        drawSnakeHead(head) {
            // Draw head base
            this.ctx.fillStyle = '#27ae60';
            this.ctx.fillRect(
                head.x * this.cellSize,
                head.y * this.cellSize,
                this.cellSize - 1,
                this.cellSize - 1
            );

            // Draw eyes based on direction
            this.ctx.fillStyle = 'white';
            const eyeSize = this.cellSize / 6;
            const eyeOffset = this.cellSize / 4;
            
            let eyeX1, eyeX2, eyeY1, eyeY2;
            
            switch(this.direction) {
                case 'right':
                    eyeX1 = eyeX2 = head.x * this.cellSize + this.cellSize - eyeOffset;
                    eyeY1 = head.y * this.cellSize + eyeOffset;
                    eyeY2 = head.y * this.cellSize + this.cellSize - eyeOffset;
                    break;
                case 'left':
                    eyeX1 = eyeX2 = head.x * this.cellSize + eyeOffset;
                    eyeY1 = head.y * this.cellSize + eyeOffset;
                    eyeY2 = head.y * this.cellSize + this.cellSize - eyeOffset;
                    break;
                case 'up':
                    eyeY1 = eyeY2 = head.y * this.cellSize + eyeOffset;
                    eyeX1 = head.x * this.cellSize + eyeOffset;
                    eyeX2 = head.x * this.cellSize + this.cellSize - eyeOffset;
                    break;
                case 'down':
                    eyeY1 = eyeY2 = head.y * this.cellSize + this.cellSize - eyeOffset;
                    eyeX1 = head.x * this.cellSize + eyeOffset;
                    eyeX2 = head.x * this.cellSize + this.cellSize - eyeOffset;
                    break;
            }

            this.ctx.beginPath();
            this.ctx.arc(eyeX1, eyeY1, eyeSize, 0, Math.PI * 2);
            this.ctx.arc(eyeX2, eyeY2, eyeSize, 0, Math.PI * 2);
            this.ctx.fill();
        }
    };

        return paths;
    },

    findNextPath(grid, remainingCells) {
        // Convert remaining cells to array for random selection
        const cells = Array.from(remainingCells)
            .map(cell => {
                const [row, col] = cell.split(',').map(Number);
                return { row, col };
            });

        // Try different start points
        for (let attempts = 0; attempts < 10; attempts++) {
            const start = cells[Math.floor(Math.random() * cells.length)];
            const path = this.growPathFromPoint(start, grid, remainingCells);
            if (path && path.length >= 3) { // Minimum path length
                return path;
            }
        }

        return null;
    },

    growPathFromPoint(start, grid, remainingCells) {
        const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];
        const path = [start];
        const visited = new Set([`${start.row},${start.col}`]);
        
        // Try to grow path
        let current = start;
        let stuck = false;
        
        while (!stuck && path.length < Math.floor(this.gridSize * 1.5)) {
            const validMoves = directions
                .map(([dx, dy]) => ({
                    row: current.row + dx,
                    col: current.col + dy
                }))
                .filter(pos => this.isValidPathCell(pos, grid, visited, remainingCells));

            if (validMoves.length === 0) {
                if (path.length >= 3) break; // Valid path found
                stuck = true;
                continue;
            }

            // Choose next move, preferring moves that continue in same direction
            const lastMove = path.length > 1 ? {
                row: current.row - path[path.length - 2].row,
                col: current.col - path[path.length - 2].col
            } : null;

            validMoves.sort((a, b) => {
                if (!lastMove) return 0;
                const aScore = this.scoreMoveDirection(a, current, lastMove);
                const bScore = this.scoreMoveDirection(b, current, lastMove);
                return bScore - aScore;
            });

            const next = validMoves[0];
            path.push(next);
            visited.add(`${next.row},${next.col}`);
            current = next;
        }

        return stuck ? null : path;
    },

    isValidPathCell(pos, grid, visited, remainingCells) {
        // Check boundaries
        if (pos.row < 0 || pos.row >= this.gridSize || 
            pos.col < 0 || pos.col >= this.gridSize) {
            return false;
        }

        // Check if cell is available
        if (!remainingCells.has(`${pos.row},${pos.col}`)) {
            return false;
        }

        // Check if already visited in current path
        if (visited.has(`${pos.row},${pos.col}`)) {
            return false;
        }

        // Check surrounding cells for other paths
        const adjacentPaths = new Set();
        const directions = [[0, 1], [1, 0], [0, -1], [-1, 0], [1, 1], [1, -1], [-1, 1], [-1, -1]];
        
        for (const [dx, dy] of directions) {
            const newRow = pos.row + dx;
            const newCol = pos.col + dy;
            
            if (newRow >= 0 && newRow < this.gridSize && 
                newCol >= 0 && newCol < this.gridSize && 
                grid[newRow][newCol] !== null) {
                adjacentPaths.add(grid[newRow][newCol]);
            }
        }

        return adjacentPaths.size <= 1;
    },

    scoreMoveDirection(next, current, lastMove) {
        const newMove = {
            row: next.row - current.row,
            col: next.col - current.col
        };
        
        // Prefer continuing in same direction
        if (newMove.row === lastMove.row && newMove.col === lastMove.col) {
            return 2;
        }
        
        // Penalize direction changes
        return 1;
    },

    setupEventListeners() {
        document.getElementById('connectDotsStart').addEventListener('click', () => {
            this.startGame();
        });

        document.getElementById('connectDotsBoard').addEventListener('click', (e) => {
            if (!this.gameActive) return;
            const dot = e.target.closest('.dot');
            if (dot) this.handleDotClick(dot);
        });

        const board = document.getElementById('connectDotsBoard');
        
        // Mouse events
        board.addEventListener('mousemove', (e) => this.handleMouseMove(e));
        board.addEventListener('mouseup', () => this.handleDragEnd());
        board.addEventListener('mouseleave', () => this.handleDragEnd());

        // Touch events
        board.addEventListener('touchmove', (e) => {
            e.preventDefault();
            this.handleTouchMove(e);
        });
        board.addEventListener('touchend', () => this.handleDragEnd());
        board.addEventListener('touchcancel', () => this.handleDragEnd());
    },

    handleDotClick(dot) {
        if (!this.gameActive) return;

        const dotInfo = this.dots.find(d => d.element === dot);
        
        // If dot is already connected, don't allow starting a new path from it
        if (dotInfo.connectedTo) {
            return;
        }

        if (!this.selectedDot) {
            this.selectedDot = dotInfo;
            dot.classList.add('selected');
            this.isDragging = true;
            this.currentPath = [{ row: dotInfo.row, col: dotInfo.col }];
            this.visitedCells = new Set([`${dotInfo.row},${dotInfo.col}`]);
            this.createTempLine(dotInfo);
        }
    },

    createTempLine(startDot) {
        this.tempLine = document.createElement('div');
        this.tempLine.className = 'connection-line temp-line';
        this.tempLine.style.backgroundColor = startDot.color;
        document.getElementById('connectDotsLines').appendChild(this.tempLine);
    },

    handleMouseMove(e) {
        if (!this.isDragging || !this.selectedDot) return;

        const board = document.getElementById('connectDotsBoard');
        const rect = board.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        
        const currentCell = this.getCellFromPosition(mouseX, mouseY);
        if (!currentCell) return;

        const cellKey = `${currentCell.row},${currentCell.col}`;
        const lastCell = this.currentPath[this.currentPath.length - 1];
        
        // Only process if we've moved to a new cell
        if (currentCell.row !== lastCell.row || currentCell.col !== lastCell.col) {
            if (this.isValidMove(currentCell.row, currentCell.col, cellKey)) {
                this.currentPath.push(currentCell);
                this.visitedCells.add(cellKey);
                this.drawPathLine();

                // Check if we've reached a matching dot
                const targetDot = this.findMatchingDot(currentCell);
                if (targetDot) {
                    this.completePath(targetDot);
                }
            }
        }
    },

    handleTouchMove(e) {
        if (!this.isDragging || !this.selectedDot || !e.touches[0]) return;

        const board = document.getElementById('connectDotsBoard');
        const rect = board.getBoundingClientRect();
        const touch = e.touches[0];
        this.updateTempLine(touch.clientX - rect.left, touch.clientY - rect.top);
    },

    updateTempLine(mouseX, mouseY) {
        if (!this.tempLine || !this.selectedDot) return;

        const currentCell = this.getCellFromPosition(mouseX, mouseY);
        if (!currentCell) return;

        // Use requestAnimationFrame for smoother updates
        requestAnimationFrame(() => {
            const lastCell = this.currentPath[this.currentPath.length - 1];
            if (currentCell.row !== lastCell.row || currentCell.col !== lastCell.col) {
                const rowDiff = Math.abs(currentCell.row - lastCell.row);
                const colDiff = Math.abs(currentCell.col - lastCell.col);
                
                if ((rowDiff === 1 && colDiff === 0) || (rowDiff === 0 && colDiff === 1)) {
                    if (this.isValidMove(currentCell.row, currentCell.col, 
                        `${currentCell.row},${currentCell.col}`, 
                        new Set(this.currentPath.map(p => `${p.row},${p.col}`)), 
                        this.currentPath)) {
                        this.currentPath.push(currentCell);
                        this.drawPathLine();
                    }
                }
            }
        });
    },

    getCellFromPosition(x, y) {
        const board = document.getElementById('connectDotsBoard');
        const rect = board.getBoundingClientRect();
        const cellWidth = rect.width / this.gridSize;
        const cellHeight = rect.height / this.gridSize;

        const col = Math.floor(x / cellWidth);
        const row = Math.floor(y / cellHeight);

        if (row >= 0 && row < this.gridSize && col >= 0 && col < this.gridSize) {
            return { row, col };
        }
        return null;
    },

    drawPathLine() {
        const linesContainer = document.getElementById('connectDotsLines');
        
        // Remove previous temporary line
        document.querySelectorAll('.connection-line.temp-line').forEach(line => line.remove());

        if (this.currentPath.length < 2) return;

        // Create a single smooth line using SVG
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.style.position = 'absolute';
        svg.style.top = '0';
        svg.style.left = '0';
        svg.style.width = '100%';
        svg.style.height = '100%';
        svg.style.pointerEvents = 'none';
        svg.classList.add('temp-line');

        // Create path element
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('fill', 'none');
        path.setAttribute('stroke', this.selectedDot.color);
        path.setAttribute('stroke-width', '8');
        path.setAttribute('stroke-linecap', 'round');
        path.setAttribute('stroke-linejoin', 'round');

        // Generate smooth path
        const pathData = this.generateSmoothPath(this.currentPath);
        path.setAttribute('d', pathData);

        svg.appendChild(path);
        linesContainer.appendChild(svg);
    },

    generateSmoothPath(points) {
        if (points.length < 2) return '';

        const board = document.getElementById('connectDotsBoard');
        const boardRect = board.getBoundingClientRect();
        
        // Get exact cell dimensions
        const cellWidth = boardRect.width / this.gridSize;
        const cellHeight = boardRect.height / this.gridSize;

        // Calculate grid offset to ensure perfect centering
        const gridOffset = {
            x: boardRect.left,
            y: boardRect.top
        };

        // Convert grid positions to absolute coordinates with precise centering
        const coords = points.map(point => {
            // Calculate exact center of each cell
            return {
                x: ((point.col * cellWidth) + (cellWidth / 2)),
                y: ((point.row * cellHeight) + (cellHeight / 2))
            };
        });

        // Start the path from the exact center of the first cell
        let pathData = `M ${coords[0].x} ${coords[0].y}`;

        // Calculate optimal corner radius based on cell size
        const cornerRadius = Math.min(cellWidth, cellHeight) * 0.35;

        for (let i = 1; i < coords.length - 1; i++) {
            const prev = coords[i - 1];
            const current = coords[i];
            const next = coords[i + 1];

            // Detect direction changes with precise calculations
            const isHorizontalFirst = Math.abs(prev.y - current.y) < 0.1;
            const isHorizontalSecond = Math.abs(current.y - next.y) < 0.1;

            if (isHorizontalFirst !== isHorizontalSecond) {
                // Calculate precise corner points for smooth turns
                const cornerStart = {
                    x: isHorizontalFirst 
                        ? current.x - (Math.sign(current.x - prev.x) * cornerRadius) 
                        : current.x,
                    y: isHorizontalFirst 
                        ? current.y 
                        : current.y - (Math.sign(current.y - prev.y) * cornerRadius)
                };

                const cornerEnd = {
                    x: isHorizontalSecond 
                        ? current.x + (Math.sign(next.x - current.x) * cornerRadius) 
                        : current.x,
                    y: isHorizontalSecond 
                        ? current.y 
                        : current.y + (Math.sign(next.y - current.y) * cornerRadius)
                };

                // Draw the path with precise coordinates
                pathData += ` L ${cornerStart.x.toFixed(3)} ${cornerStart.y.toFixed(3)}`;
                pathData += ` Q ${current.x.toFixed(3)} ${current.y.toFixed(3)}, ${cornerEnd.x.toFixed(3)} ${cornerEnd.y.toFixed(3)}`;
            } else {
                // Draw straight line segments with precise coordinates
                pathData += ` L ${current.x.toFixed(3)} ${current.y.toFixed(3)}`;
            }
        }

        // End the path at the exact center of the last cell
        pathData += ` L ${coords[coords.length - 1].x.toFixed(3)} ${coords[coords.length - 1].y.toFixed(3)}`;
        return pathData;
    },

    handleDragEnd() {
        if (!this.isDragging || !this.selectedDot) return;

        // Check if we've reached a valid target through our path
        const lastCell = this.currentPath[this.currentPath.length - 1];
        const targetDot = this.dots.find(dot => 
            dot.row === lastCell.row && 
            dot.col === lastCell.col && 
            dot.pairId === this.selectedDot.pairId &&
            dot !== this.selectedDot &&
            !dot.connectedTo // Only connect to unconnected dots
        );

        if (targetDot && this.isValidPath(this.currentPath)) {
            // Create new connection using the current path
            this.connectDotsWithPath(this.selectedDot, targetDot, this.currentPath);
            this.moveCount++;
            this.score += 10;
            this.updateScore();
            this.checkGameComplete();
        }

        // Clean up only temporary elements
        this.isDragging = false;
        document.querySelectorAll('.connection-line.temp-line').forEach(line => line.remove());
        this.selectedDot.element.classList.remove('selected');
        this.selectedDot = null;
        this.currentPath = [];
        document.querySelectorAll('.dot.highlight').forEach(dot => dot.classList.remove('highlight'));
    },

    isValidPath(path) {
        // Check if path is continuous (no jumps)
        for (let i = 0; i < path.length - 1; i++) {
            const current = path[i];
            const next = path[i + 1];
            
            // Check if cells are adjacent (no diagonal)
            const rowDiff = Math.abs(current.row - next.row);
            const colDiff = Math.abs(current.col - next.col);
            
            if (!(rowDiff === 1 && colDiff === 0) && !(rowDiff === 0 && colDiff === 1)) {
                return false;
            }
        }
        return true;
    },

    connectDotsWithPath(dot1, dot2, path) {
        // Create permanent SVG line
        const linesContainer = document.getElementById('connectDotsLines');
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.style.position = 'absolute';
        svg.style.top = '0';
        svg.style.left = '0';
        svg.style.width = '100%';
        svg.style.height = '100%';
        svg.style.pointerEvents = 'none';
        svg.classList.add('permanent-line');

        const pathElement = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        pathElement.setAttribute('fill', 'none');
        pathElement.setAttribute('stroke', dot1.color);
        pathElement.setAttribute('stroke-width', '8');
        pathElement.setAttribute('stroke-linecap', 'round');
        pathElement.setAttribute('stroke-linejoin', 'round');

        const pathData = this.generateSmoothPath(path);
        pathElement.setAttribute('d', pathData);

        svg.appendChild(pathElement);
        linesContainer.appendChild(svg);

        // Store line information
        this.lines.push({
            start: dot1,
            end: dot2,
            color: dot1.color,
            element: svg,
            path: path
        });

        // Mark all tiles in the path as covered
        path.forEach(point => {
            this.coveredTiles[point.row][point.col] = true;
        });

        // Mark dots as connected
        dot1.element.classList.add('connected');
        dot2.element.classList.add('connected');
        dot1.connectedTo = dot2;
        dot2.connectedTo = dot1;

        this.clearTemporaryElements(dot1.color);

        // Check for game completion after each connection
        this.checkGameComplete();
    },

    clearTemporaryElements(color) {
        // Remove temporary lines of the specific color
        document.querySelectorAll('.temp-line').forEach(line => {
            const tempPath = line.querySelector('path');
            if (tempPath && tempPath.getAttribute('stroke') === color) {
                line.style.opacity = '0';
                setTimeout(() => line.remove(), 150); // Smooth fade out
            }
        });

        // Remove highlights from dots of the same color
        this.dots.forEach(dot => {
            if (dot.color === color) {
                dot.element.classList.remove('highlight');
            }
        });

        // Reset current path if it's for the same color
        if (this.selectedDot && this.selectedDot.color === color) {
            this.currentPath = [];
            this.selectedDot = null;
        }
    },

    removeLine(line) {
        // Remove all line elements
        line.elements.forEach(element => element.remove());
        
        // Remove from lines array
        const index = this.lines.indexOf(line);
        if (index > -1) {
            this.lines.splice(index, 1);
        }

        // Remove connected class from dots
        line.start.element.classList.remove('connected');
        line.end.element.classList.remove('connected');
    },

    drawLines() {
        const linesContainer = document.getElementById('connectDotsLines');
        linesContainer.innerHTML = '';

        this.lines.forEach(line => {
            const lineElement = document.createElement('div');
            lineElement.className = 'connection-line';
            lineElement.style.backgroundColor = line.color;

            const start = line.start.element.getBoundingClientRect();
            const end = line.end.element.getBoundingClientRect();
            const board = document.getElementById('connectDotsBoard').getBoundingClientRect();

            const length = Math.hypot(end.left - start.left, end.top - start.top);
            const angle = Math.atan2(end.top - start.top, end.left - start.left) * 180 / Math.PI;

            lineElement.style.width = `${length}px`;
            lineElement.style.left = `${start.left - board.left}px`;
            lineElement.style.top = `${start.top - board.top}px`;
            lineElement.style.transform = `rotate(${angle}deg)`;

            linesContainer.appendChild(lineElement);
        });
    },

    checkGameComplete() {
        // Check if all dot pairs are connected
        const allConnected = this.dotPairs.every(pair => {
            return this.lines.some(line => {
                const dot1 = line.start;
                const dot2 = line.end;
                const pairDots = pair.dots;
                
                return (
                    (dot1.row === pairDots[0].row && dot1.col === pairDots[0].col &&
                     dot2.row === pairDots[1].row && dot2.col === pairDots[1].col) ||
                    (dot1.row === pairDots[1].row && dot1.col === pairDots[1].col &&
                     dot2.row === pairDots[0].row && dot2.col === pairDots[0].col)
                );
            });
        });

        // Check if all tiles are covered
        const allTilesCovered = this.coveredTiles.every(row => 
            row.every(cell => cell)
        );

        if (allConnected && allTilesCovered) {
            this.gameActive = false; // Stop further gameplay
            setTimeout(() => {
                this.showCompletionPopup(); // Show popup with slight delay
            }, 300);
        }

        return allConnected && allTilesCovered;
    },

    showCompletionPopup() {
        // Remove any existing popup
        const existingPopup = document.querySelector('.game-completion-popup');
        if (existingPopup) {
            existingPopup.remove();
        }

        // Create popup
        const popup = document.createElement('div');
        popup.className = 'game-completion-popup';
        popup.innerHTML = `
            <div class="popup-content">
                <h2>🎉 Congratulations!</h2>
                <p>All dots connected and tiles covered!</p>
                <p>Final Score: ${this.score}</p>
                <p>Moves: ${this.moveCount}</p>
                <div class="popup-buttons">
                    <button class="play-again-btn">Play Again</button>
                    <button class="change-size-btn">Change Size</button>
                </div>
            </div>
        `;

        // Add popup to the game board container
        const container = document.querySelector('.game-board-container');
        if (container) {
            container.appendChild(popup);
            // Add fade-in animation
            setTimeout(() => {
                popup.style.opacity = '1';
            }, 10);
        }

        // Add event listeners
        popup.querySelector('.play-again-btn').addEventListener('click', () => {
            popup.style.opacity = '0';
            setTimeout(() => {
                popup.remove();
                this.startGame();
            }, 300);
        });

        popup.querySelector('.change-size-btn').addEventListener('click', () => {
            popup.style.opacity = '0';
            setTimeout(() => {
                popup.remove();
                document.getElementById('gridSizeSelect').focus();
            }, 300);
        });
    },

    updateScore() {
        const scoreElement = document.getElementById('connectDotsScore');
        if (scoreElement) {
            scoreElement.textContent = this.score;
            
            // Add animation effect for score updates
            scoreElement.classList.add('score-update');
            setTimeout(() => scoreElement.classList.remove('score-update'), 300);
        }
    },

    resetGame() {
        this.dots = [];
        this.lines = [];
        this.dotPairs = [];
        this.selectedDot = null;
        this.gameActive = false;
        this.score = 0;
        this.moveCount = 0;
        this.startTime = null;
        // Reset covered tiles
        this.coveredTiles = Array.from({ length: this.gridSize }, 
            () => Array(this.gridSize).fill(false)
        );
        this.updateScore();
        this.clearBoard();
    },

    startGame() {
        this.resetGame();
        this.gameActive = true;
        this.startTime = Date.now();
        this.gridSize = parseInt(document.getElementById('gridSizeSelect').value);
        this.createBoard();
        this.generateDotPairs();
        document.getElementById('connectDotsStart').textContent = 'Restart';
    },

    findPath(start, end) {
        // Convert start and end points to string format for comparison
        const startPoint = `${start.row},${start.col}`;
        const endPoint = `${end.row},${end.col}`;
        
        const queue = [[startPoint]];
        const visited = new Set([startPoint]);
        
        // Define possible movement directions
        const directions = [
            [0, 1],  // Right
            [1, 0],  // Down
            [0, -1], // Left
            [-1, 0]  // Up
        ];

        while (queue.length > 0) {
            const currentPath = queue.shift();
            const currentPoint = currentPath[currentPath.length - 1];
            const [currentRow, currentCol] = currentPoint.split(',').map(Number);

            // Check if we've reached the end point
            if (currentPoint === endPoint) {
                return this.validatePath(currentPath, start.color);
            }

            // Try all possible directions
            for (const [dx, dy] of directions) {
                const newRow = currentRow + dx;
                const newCol = currentCol + dy;
                const newPoint = `${newRow},${newCol}`;

                if (this.isValidMove(newRow, newCol, newPoint, visited, currentPath)) {
                    visited.add(newPoint);
                    queue.push([...currentPath, newPoint]);
                }
            }
        }

        return null; // No valid path found
    },

    isValidMove(row, col, point, visited, currentPath) {
        // Check boundaries
        if (row < 0 || row >= this.gridSize || col < 0 || col >= this.gridSize) {
            return false;
        }

        // Check if point is already visited in current path
        if (visited.has(point)) {
            return false;
        }

        // Check if there's a different colored dot in this cell
        const dotInCell = this.dots.find(dot => 
            dot.row === row && 
            dot.col === col && 
            dot !== this.selectedDot && 
            dot.pairId !== this.selectedDot.pairId
        );
        if (dotInCell) {
            return false;
        }

        // Check if cell is part of another line's path
        const cellIsInPath = this.lines.some(line => 
            line.path.some(pathCell => 
                pathCell.row === row && pathCell.col === col
            )
        );
        if (cellIsInPath) {
            return false;
        }

        return true;
    },

    wouldPathCrossLines(from, to) {
        if (!from || !to) return false;

        const [x1, y1] = from.split(',').map(Number);
        const [x2, y2] = to.split(',').map(Number);

        // Check intersection with existing lines
        return this.lines.some(line => {
            const [startRow, startCol] = [line.start.row, line.start.col];
            const [endRow, endCol] = [line.end.row, line.end.col];

            return this.doLinesIntersect(
                {x: x1, y: y1},
                {x: x2, y: y2},
                {x: startRow, y: startCol},
                {x: endRow, y: endCol}
            );
        });
    },

    doLinesIntersect(p1, p2, p3, p4) {
        // Helper function to determine if two line segments intersect
        const ccw = (A, B, C) => {
            return (C.y - A.y) * (B.x - A.x) > (B.y - A.y) * (C.x - A.x);
        };

        return ccw(p1, p3, p4) !== ccw(p2, p3, p4) && 
               ccw(p1, p2, p3) !== ccw(p1, p2, p4);
    },

    validatePath(path, color) {
        // Convert path points to coordinates
        const coordinates = path.map(point => {
            const [row, col] = point.split(',').map(Number);
            return { row, col };
        });

        // Check if path is clear of obstacles
        for (let i = 0; i < coordinates.length - 1; i++) {
            const current = coordinates[i];
            const next = coordinates[i + 1];

            // Check for diagonal movement (not allowed)
            if (Math.abs(current.row - next.row) + Math.abs(current.col - next.col) !== 1) {
                return null;
            }

            // Check for intersections with existing lines
            if (this.wouldPathCrossLines(
                `${current.row},${current.col}`,
                `${next.row},${next.col}`
            )) {
                return null;
            }
        }

        return coordinates;
    },

    generatePathsForPairs() {
        this.paths = [];
        this.clearLines();

        // Process each dot pair
        for (const pair of this.dotPairs) {
            const start = pair.dots[0];
            const end = pair.dots[1];

            // Find a valid path between the dots
            const path = this.findPath(
                { row: start.row, col: start.col, color: pair.color },
                { row: end.row, col: end.col, color: pair.color }
            );

            if (path) {
                this.paths.push({
                    path: path,
                    color: pair.color,
                    pairId: pair.id
                });
                this.drawLine(path[0], path[path.length - 1], pair.color);
            }
        }

        return this.paths.length === this.dotPairs.length;
    },

    clearLines() {
        // Only remove temporary lines, keep permanent ones
        document.querySelectorAll('.connection-line.temp-line').forEach(line => line.remove());
    },

    drawLine(start, end, color) {
        const linesContainer = document.getElementById('connectDotsLines');
        if (!linesContainer) return;

        const line = document.createElement('div');
        line.className = 'connection-line';
        line.style.backgroundColor = color;

        // Get positions for start and end dots
        const startDot = document.querySelector(
            `.dot[data-row="${start.row}"][data-col="${start.col}"]`
        );
        const endDot = document.querySelector(
            `.dot[data-row="${end.row}"][data-col="${end.col}"]`
        );

        if (!startDot || !endDot) return;

        const startRect = startDot.getBoundingClientRect();
        const endRect = endDot.getBoundingClientRect();
        const containerRect = linesContainer.getBoundingClientRect();

        // Calculate line position and dimensions
        const startX = startRect.left + startRect.width / 2 - containerRect.left;
        const startY = startRect.top + startRect.height / 2 - containerRect.top;
        const endX = endRect.left + endRect.width / 2 - containerRect.left;
        const endY = endRect.top + endRect.height / 2 - containerRect.top;

        const length = Math.hypot(endX - startX, endY - startY);
        const angle = Math.atan2(endY - startY, endX - startX) * 180 / Math.PI;

        // Position and rotate the line
        line.style.width = `${length}px`;
        line.style.left = `${startX}px`;
        line.style.top = `${startY}px`;
        line.style.transform = `rotate(${angle}deg)`;

        linesContainer.appendChild(line);

        // Store the line information
        this.lines.push({
            element: line,
            start: start,
            end: end,
            color: color
        });
    },

    checkPathIntersection(path1, path2) {
        for (let i = 0; i < path1.length - 1; i++) {
            const line1Start = path1[i];
            const line1End = path1[i + 1];

            for (let j = 0; j < path2.length - 1; j++) {
                const line2Start = path2[j];
                const line2End = path2[j + 1];

                if (this.doLinesIntersect(
                    {x: line1Start.row, y: line1Start.col},
                    {x: line1End.row, y: line1End.col},
                    {x: line2Start.row, y: line2Start.col},
                    {x: line2End.row, y: line2End.col}
                )) {
                    return true;
                }
            }
        }
        return false;
    },

    highlightPath(path, color) {
        path.forEach((point, index) => {
            if (index < path.length - 1) {
                const nextPoint = path[index + 1];
                this.drawLine(point, nextPoint, color);
            }
        });
    },

    createDot(row, col, color, pairId) {
        const cell = document.querySelector(`.grid-cell[data-row="${row}"][data-col="${col}"]`);
        if (!cell) {
            console.error(`Cell not found at row ${row}, col ${col}`);
        return;
    }
    
        const dot = document.createElement('div');
        dot.className = 'dot';
        dot.style.backgroundColor = color;
        dot.dataset.pairId = pairId;
        dot.dataset.row = row;
        dot.dataset.col = col;
        cell.appendChild(dot);

        // Store dot information
        this.dots.push({
            element: dot,
            row: parseInt(row),
            col: parseInt(col),
            color: color,
            pairId: pairId
        });

        // Add click event listener
        dot.addEventListener('click', () => {
            if (!this.gameActive) return;
            this.handleDotClick(dot);
        });
    },

    findMatchingDot(cell) {
        return this.dots.find(dot => 
            dot.row === cell.row && 
            dot.col === cell.col && 
            dot.pairId === this.selectedDot.pairId && 
            dot !== this.selectedDot &&
            !dot.connectedTo
        );
    },

    completePath(targetDot) {
        this.isDragging = false;
        
        // Create permanent connection
        this.connectDotsWithPath(this.selectedDot, targetDot, [...this.currentPath]);
        
        // Update score
        this.moveCount++;
        this.score += 10;
        this.updateScore();
        
        // Clean up temporary line
        if (this.tempLine) {
            this.tempLine.remove();
            this.tempLine = null;
        }
        
        // Reset selection
        this.selectedDot.element.classList.remove('selected');
        this.selectedDot = null;
        this.currentPath = [];
        this.visitedCells = new Set();
        
        // Check if game is complete
        this.checkGameComplete();
    },

    isValidMove(row, col, cellKey) {
        // Check boundaries
        if (row < 0 || row >= this.gridSize || col < 0 || col >= this.gridSize) {
            return false;
        }

        // Check if cell is already in current path
        if (this.visitedCells.has(cellKey)) {
            return false;
        }

        const lastCell = this.currentPath[this.currentPath.length - 1];
        
        // Ensure move is only horizontal or vertical (no diagonal)
        const rowDiff = Math.abs(row - lastCell.row);
        const colDiff = Math.abs(col - lastCell.col);
        if (!((rowDiff === 1 && colDiff === 0) || (rowDiff === 0 && colDiff === 1))) {
            return false;
        }

        // Check for other dots or existing lines
        const hasOtherDot = this.dots.some(dot => 
            dot.row === row && 
            dot.col === col && 
            dot.pairId !== this.selectedDot.pairId
        );
        
        const hasExistingLine = this.lines.some(line => 
            line.path.some(cell => cell.row === row && cell.col === col)
        );

        return !hasOtherDot && !hasExistingLine;
    }
};

// Initialize game when modal opens
document.getElementById('connectDotsBtn').addEventListener('click', () => {
    ConnectDots.init();
});

    </script>
</body>
</html>
